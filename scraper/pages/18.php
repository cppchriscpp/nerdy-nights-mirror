
					<span style="font-weight: bold;">Last Week:</span> <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=24885" target="_blank">Tempo, Note Lengths, Buffering and Rests</a><br><br><span style="font-weight: bold;">This Week</span>: Volume Envelopes<br><font size="4"><b><br>Volume Envelopes</b></font><br><br>This week we will
add volume envelopes to our engine.&#xA0; A <span style="font-weight: bold;">volume envelope</span> is a series of
volume values that are applied to a note one frame at a time.&#xA0; For
example, if we had a volume envelope that looked like this:<br><br><span style="font-family: Courier New;">F E D C 9 5 0</span><br><br>Then
whenever we played a note, it would have a volume of F on the first
frame, a volume of E on the second frame, then D, then C, then 9, then
5 until it is finally silenced with a volume of 0 on the 7th frame.&#xA0;
Applying this volume envelope on our notes would give them a sharp,
short staccato feel.&#xA0; Conversely, if we had a volume envelope that
looked like this:<br><br><span style="font-family: Courier New;">1 1 2 2 3 3 4 4 7 7 8 8 A A C C D D E E F F F</span><br><br>Each note would start very quietly and fade in to full volume.&#xA0; Look at this volume envelope:<br><br><span style="font-family: Courier New;">D D D C B 0 0 0 0 0 0 0 0 6 6 6 5 4 0</span><br><br>Here
we start at a high volume (D) and let it ring for 5 frames.&#xA0; Then we
silence the note for 8 frames.&#xA0; Then the note comes back at a very low
volume for 5 frames.&#xA0; Notes using this volume envelope would sound like
they had an faint echo.<br><br>As you can see, volume envelopes are pretty cool.&#xA0; We can get a lot of different sounds out of them.&#xA0; Let&apos;s add them in.<br><br><b>Channels</b><br>Volume
envelopes are best suited for the square and noise channels where we
have full control of the volume.&#xA0; The triangle channel on the other
hand doesn&apos;t allow much volume control.&#xA0; It only has two settings: full
blast and off.&#xA0; We can still apply volume envelopes in a limited way
though.&#xA0; Consider these two volume envelopes:<br><br><span style="font-family: Courier New;">0F 0E 0D 0C 09 05 00</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">04 04 05 05 06 06 07 07 08 08 09 09 0A 0A 00</span><br><br>These two envelopes would have a vastly different sound on the square channels, but to the triangle they look like this:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">On On On On On On Off</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">On On On On On On On On On On On On On On Off</span><br><br>You
don&apos;t get the subtle shifts in volume, but you do get a different
length.&#xA0; We can use volume envelopes that end in 00 to control when the
triangle key-off occurs.&#xA0; Not as cool as full volume control, but still
useful.<br><br><b>Defining volume envelopes</b><br>First let&apos;s define some volume envelopes so we have some data to work with.&#xA0; We&apos;ll use some of the examples from above:<br><br><span style="font-family: Courier New;">se_ve_1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $0F, $0E, $0D, $0C, $09, $05, $00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $FF</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_ve_2:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01, $01, $02, $02, $03, $03, $04, $04, $07, $07</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $08, $08, $0A, $0A, $0C, $0C, $0D, $0D, $0E, $0E</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $0F, $0F</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $FF</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_ve_3:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $0D, $0D, $0D, $0C, $0B, $00, $00, $00, $00, $00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $00, $00, $00, $00, $06, $06, $06, $05, $04, $00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $FF</span><br><br>Notice
that I terminated each envelope with $FF.&#xA0; We need some terminator
value so the engine will know when we&apos;ve reached the end of the
envelope.&#xA0; We could have used any value, but $FF is pretty common.<br><br>Next we will make a pointer table that holds the addresses of our volume envelopes:<br><br><span style="font-family: Courier New;">volume_envelopes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_ve_1, se_ve_2, se_ve_3</span><br>&#xA0;&#xA0; &#xA0;<br><b>Declaring variables</b><br>In
order to apply a volume envelope to a particular stream, we will need a
variable that tells us which one to use.&#xA0; We will also need an index
variable that tells us our current position within the volume envelope:<br><br><span style="font-family: Courier New;">stream_ve .rs 6&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;current volume envelope</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_ve_index .rs 6&#xA0;&#xA0; ;current position within the volume envelope</span><br><br>stream_ve
will tell us which volume envelope to use.&#xA0; Code-wise, it will act as
an index into our pointer table so we know where to read from.&#xA0; Sound
familiar?&#xA0; It works the same way as &quot;song number&quot; did for loading a
song.&#xA0; We aren&apos;t there yet, but here&apos;s a peek at how we will use these
variables to read from the volume envelopes. (x holds the stream
number):<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save y because we are about to destroy it.</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ve, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which volume envelope?</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2 because we are indexing into a table of addresses (words)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda volume_envelopes, y&#xA0;&#xA0;&#xA0;&#xA0; ;get the low byte of the address from the pointer table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda volume_envelopes+1, y&#xA0;&#xA0; ;get the high byte of the address</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy stream_ve_index, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;our current position within the volume envelope.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;grab the value.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;check against $FF (our termination value)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;set the volume</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;increment stream_ve_index</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;etc</span><br>&#xA0;&#xA0; &#xA0;<br>Compare this code to the beginning of the sound_load routine.&#xA0; Are you starting to see a pattern?<br>&#xA0;&#xA0; &#xA0;<br><b>Initializing</b><br>Whenever
we add a new feature, we need to consider how we should initialize it.&#xA0;
Every stream in our music data will potentially have a different volume
envelope, so we should add a volume envelope field to our header.&#xA0;
Volume envelopes will deprecate our old &quot;initial volume&quot; field, but we
will still need to have duty cycle info, so we&apos;ll just rename that
field:<br><br><span style="font-family: Courier New;">main header:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">byte #&#xA0; | what it tells us</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | number of streams</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">01+&#xA0;&#xA0;&#xA0;&#xA0; | stream headers (one for each stream)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream headers:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">byte #&#xA0; | what it tells us</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | which stream (stream number)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | status byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">02&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">03&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | initial duty (for triangle, set the 7bit)</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">04&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | volume envelope</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">05-06&#xA0;&#xA0; | pointer to data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">07&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | initial tempo</span><br><br>To
read this data from the header, we will have to insert the following
code into our sound_load routine (after reading the duty):<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the stream&apos;s volume envelope</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ve, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br>&#xA0;&#xA0; &#xA0;<br>Notes will always start from the beginning of the volume envelope, so we can just initialize stream_ve_index to 0:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ve_index, x</span><br>&#xA0;&#xA0; &#xA0;<br>Now we just need to make sure to assign volume envelopes to all the streams in our song data and we&apos;re ready to go:<br><br><span style="font-family: Courier New;">song5_header:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;1 stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte SFX_1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;status byte (stream enabled)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte SQUARE_2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $70&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;initial duty (01).&#xA0; Initial volume deprecated.</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .byte $00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the first volume envelope (se_ve_1)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song5_square2 ;pointer to stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;tempo..very fast tempo</span><br><br>Remember
that you can always create descriptive aliases for your volume
envelopes if you don&apos;t want to remember which number is which:<br><br><span style="font-family: Courier New;">;volume envelope aliases</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">ve_short_staccato = $00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">ve_fade_in = $01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">ve_blip_echo = $02</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">song5_header:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;1 stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte SFX_1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;status byte (stream enabled)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte SQUARE_2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $7F&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;initial duty (01).&#xA0; Initial volume deprecated.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte <span style="color: rgb(255, 0, 0);">ve_short_staccato</span>&#xA0;&#xA0; ;the first volume envelope (se_ve_1)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song5_square2 ;pointer to stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;tempo..very fast tempo</span><br>&#xA0;&#xA0; &#xA0;<br>Using
aliases is a good idea because the assembler will give you an error if
you mistype your alias.&#xA0; If you mistype your number, and it is still a
valid number, the assembler won&apos;t know there&apos;s a problem and will
assemble it.&#xA0; This kind of bug in your data can be hard to trace.<br><br><br><font size="3"><b>Implementing Volume Envelopes</b></font><br><br>To
implement volume envelopes, we need to modify the code where we set the
volume.&#xA0; Instead of using a fixed value like we were doing before, we
need to read from our current position in the volume envelope and use
that value instead.&#xA0; Our volume code is starting to get a little
complicated, so let&apos;s pull it out into its own subroutine.&#xA0; This will
make our code easier to follow:<br><br><span style="font-family: Courier New;">;----------------------------------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">; se_set_temp_ports will copy a stream&apos;s sound data to the temporary apu variables</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; input:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; X: stream number</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_set_temp_ports:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">jsr se_set_stream_volume&#xA0;&#xA0;&#xA0; ;let&apos;s stick all of our volume code into a new subroutine</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;less cluttered that way</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$08</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+1, y&#xA0;&#xA0;&#xA0;&#xA0; ;sweep</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+2, y&#xA0;&#xA0;&#xA0;&#xA0; ;period LO</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+3, y&#xA0;&#xA0;&#xA0;&#xA0; ;period HI</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts&#xA0;&#xA0; &#xA0;</span><br><br>What
should our new subroutine se_set_stream_volume do?&#xA0; First it needs to
read a value from our stream&apos;s volume envelope.&#xA0; Then it needs to
modify the stream&apos;s volume using that value.&#xA0; Then we need to update
our position within the volume envelope.&#xA0; Finally it needs to check to
see if we are resting, and silence the stream if we are (we wrote this
code last week).&#xA0; It looks something like this (new code in red):<br><br><br><span style="font-family: Courier New;">se_set_stream_volume:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save our index into soft_apu_ports (we are about to destroy y)</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda stream_ve, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which volume envelope?</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2 because we are indexing into a table of addresses (words)</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda volume_envelopes, y&#xA0;&#xA0;&#xA0;&#xA0; ;get the low byte of the address from the pointer table</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta sound_ptr&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;put it into our pointer variable</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda volume_envelopes+1, y&#xA0;&#xA0; ;get the high byte of the address</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">.read_ve:</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; ldy stream_ve_index, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;our current position within the volume envelope.</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;grab the value.</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; cmp #$FF</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .set_vol&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if not FF, set the volume</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; dec stream_ve_index, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if FF, go back one and read again</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; jmp .read_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0; FF essentially tells us to repeat the last</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0; volume value for the remainder of the note</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">.set_vol:</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta sound_temp2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save our new volume value (about to destroy A)</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda stream_vol_duty, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;get current vol/duty settings</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; and #$F0&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;zero out the old volume</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; ora sound_temp2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;OR our new volume in.</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;get our index into soft_apu_ports</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta soft_apu_ports, y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;store the volume in our temp port</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; inc stream_ve_index, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set our volume envelop index to the next position</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><br style="font-family: Courier New;"><span style="font-family: Courier New;">.rest_check:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;check the rest flag. if set, overwrite volume with silence value </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%00000010</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .done&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if clear, no rest, so quit</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #TRIANGLE&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if triangle, silence with #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .tri&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else, silence with #$30</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$30&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .store&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this always branches.&#xA0; bne is cheaper than a jmp</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.store:&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>After
we read a value from our volume envelope, we AND stream_vol_duty with
#$F0.&#xA0; This has the nice effect of clearing the old volume while
preserving our squares&apos; duty cycle settings.&#xA0; But we need to be careful
here.&#xA0; Recall that the triangle channel&apos;s on/off status is controlled
by the low 7 bits of the port:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">TRI_CTRL ($4008)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">76543210</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">||||||||</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">|+++++++- Value</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">+-------- Control Flag (0: use internal counters; 1: disable internal counters)</span><br><br>If
any of those Value bits are set, the triangle channel will be
considered on.&#xA0; Consider what happens if bit 4, 5 or 6 happen to be
set.&#xA0; In this case, ANDing with #$F0 won&apos;t turn the triangle channel
off.&#xA0; If the volume we pull from the volume envelope is 0, it won&apos;t
silence our triangle channel because bit 4, 5 or 6 will still be set.&#xA0;
If we are careful not to set these bits in our song headers, the
problem should never come up.&#xA0; But for completeness we should fix it:<br><br><span style="font-family: Courier New;">se_set_stream_volume:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save our index into soft_apu_ports (we are about to destroy y)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ve, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which volume envelope?</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2 because we are indexing into a table of addresses (words)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda volume_envelopes, y&#xA0;&#xA0;&#xA0;&#xA0; ;get the low byte of the address from the pointer table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;put it into our pointer variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda volume_envelopes+1, y&#xA0;&#xA0; ;get the high byte of the address</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.read_ve:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy stream_ve_index, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;our current position within the volume envelope.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;grab the value.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$FF</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .set_vol&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if not FF, set the volume</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dec stream_ve_index, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if FF, go back one and read again</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .read_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0; FF essentially tells us to repeat the last</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0; volume value for the remainder of the note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.set_vol:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_temp2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save our new volume value (about to destroy A)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;<span style="color: rgb(255, 0, 0);"> cpx #TRIANGLE&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .squares&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if not triangle channel, go ahead</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda sound_temp2</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .squares&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if volume not zero, go ahead (treat same as squares)</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda #$80</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bmi .store_vol&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else silence the channel with #$80</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">.squares:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_vol_duty, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;get current vol/duty settings</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #$F0&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;zero out the old volume</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ora sound_temp2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;OR our new volume in.</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">.store_vol:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;get our index into soft_apu_ports</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports, y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;store the volume in our temp port</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inc stream_ve_index, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set our volume envelop index to the next position</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">.rest_check:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;check the rest flag. if set, overwrite volume with silence value </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%00000010</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .done&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if clear, no rest, so quit</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #TRIANGLE&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if triangle, silence with #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .tri&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else, silence with #$30</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$30&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .store&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this always branches.&#xA0; bne is cheaper than a jmp</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.store:&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br><b>New notes</b><br>The
last thing we need to consider is new notes.&#xA0; When an old note finishes
and we start playing a new note, we will want to reset the volume
envelope back to the beginning.&#xA0; This is as easy as setting
stream_ve_index to 0 when we read a new note:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;...snip... (setup pointers, read byte, test range, etc)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;save our index into the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table+1, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;restore data stream index</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">lda #$00</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta stream_ve_index, x&#xA0; ;reset the volume envelope.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;check if it&apos;s a rest and modify the status flag appropriately</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_check_rest&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;...snip... (update pointer)</span><br>&#xA0;&#xA0; &#xA0;<br>And now we have volume envelopes.<br><br><b>Putting It All Together</b><br>Download and unzip the <a href="downloads/NerdyNightsSoundSourceCollection/envelopes.zip" target="_blank">envelopes.zip</a> sample files.&#xA0; Make sure the following files are in the same folder as NESASM3:<br><br>&#xA0;&#xA0;&#xA0; envelopes.asm<br>&#xA0;&#xA0;&#xA0; sound_engine.asm<br>&#xA0;&#xA0;&#xA0; envelopes.chr<br>&#xA0;&#xA0;&#xA0; note_table.i<br>&#xA0;&#xA0;&#xA0; note_length_table.i<br>&#xA0;&#xA0;&#xA0; vol_envelopes.i<br>&#xA0;&#xA0;&#xA0; song0.i<br>&#xA0;&#xA0;&#xA0; song1.i<br>&#xA0;&#xA0;&#xA0; song2.i<br>&#xA0;&#xA0;&#xA0; song3.i<br>&#xA0;&#xA0;&#xA0; song4.i<br>&#xA0;&#xA0;&#xA0; song5.i<br>&#xA0;&#xA0;&#xA0; envelopes.bat<br><br>Double click envelopes.bat. That will run NESASM3 and should produce the envelopes.nes file. Run that NES file in FCEUXD SP.<br><br>Use the controller to select songs and play them.&#xA0; Controls are as follows:<br>&#xA0;&#xA0; &#xA0;<br><b>Up</b>: Play<br><b>Down</b>: Stop <br><b>Right</b> : Next Song/SFX<br><b>Left </b>: Previous Song/SFX<br><br>Song0 is a silence song.&#xA0; Not selectable.<br>Song1 is a boss song from The Guardian Legend, almost the same as the original.<br>Song2 is the same short sound effect from last week.<br>Song3 is a song from Dragon Warrior, very close to the original.<br>Song4 is the same song4 as last week, but volume envelopes allow us to save some bytes by reducing rests.<br>Song5 is a short sound effect, same as last week.<br><br>Try
creating your own songs and sound effects and add them into the mix.&#xA0;
To add a new song you will need to take the following steps:<br><br>1)
create a song header and song data (use the included songs as
reference).&#xA0; Don&apos;t forget to select a volume envelope for each stream
in your header.&#xA0; Data streams are terminated with $FF.<br>2) add your header to the song_headers pointer table at the bottom of sound_engine.asm<br>3) update the constant NUM_SONGS to reflect the new song number total (also at the bottom of sound_engine.asm)<br><br>Try
making your own volume envelopes too.&#xA0; To do so you will need to modify
vol_envelopes.i.&#xA0; Remember that volume envelopes are terminated with
$FF.<br>
<br><b>Next Week</b>: <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25583" target="_blank">Opcodes, Looping</a><br>
				