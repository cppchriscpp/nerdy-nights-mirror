
					<b>Last Week</b>: <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23024" target="_blank">Sound Engine Basics, Skeleton sound engine</a><br><br><b>This Week</b>: Sound Data, Pointer Tables, Headers<br><br><font size="4"><b>Designing Sound Data</b></font><br><br>We
have a skeleton sound engine in place.&#xA0; Time to pack it with flesh and
organs.&#xA0; Before we can play a song, we will have to load a song.&#xA0;
Before we can load a song, we will need song data.&#xA0; So our next step is
to decide how our sound data will look.&#xA0; We&apos;ll need to design our data
format, create some test data and then build our engine to read and
play that data.<br><br><b>Data Formats</b><br>So how do we go about
designing a sound data format?&#xA0; A good place to start would be to look
at what we are aiming to play.&#xA0; We know that our sound engine will have
two basic types of sound data:<br><br>1. Music<br>2. Sound Effects (SFX)<br><br><i>Music</i> plays in the background.&#xA0; It uses the first 4 channels, has a tempo, and usually loops over and over again.<br><br><i>Sound Effects</i> are triggered by game events (eg, ball hitting a paddle) and don&apos;t loop indefinitely.<br><br>Sound
effects have the job of communicating to the player what is going on
right now, so they have priority over music.&#xA0; If there is music playing
on the Square 2 channel, and a sound effect is also using the Square 2
channel, the sound effect should play instead of the music.<br><br>Depending
on the game, some sound effects may have higher priority than others.&#xA0;
For example, in a Zelda-like game the sound of the player taking damage
would have priority over the sound of the player swinging their sword.&#xA0;
The former communicates critical information to the player while the
latter is just for effect.<br><br><b>Streams</b><br>As mentioned above,
a sound effect will have to share a channel (or channels) with the
music.&#xA0; This is unavoidable because music typically uses all the
channels at once, all the time.&#xA0; So when a sound effect starts playing,
it has to steal a channel (or more) away from the music.&#xA0; The music
will continue to play on the other channels, but the shared channel
will go to the sound effect.&#xA0; This creates an interesting problem: if
we stop music on a channel to play a sound effect, how do we know where
to resume the music on that channel when the sound effect is finished?<br><br>The
answer is that we don&apos;t actually stop the music on the shared channel.&#xA0;
We still advance it frame by frame in time with the other music
channels.&#xA0; We just don&apos;t write its data to the APU ports when a sound
effect is playing.<br><br>To do this, we will need to keep track of multiple streams of sound data.&#xA0; A data <b>stream</b>
is a sequence of bytes stored in ROM that the sound engine will read
and translate into APU writes.&#xA0; Each stream corresponds to one
channel.&#xA0; Music will have 4 data streams - one for each channel.&#xA0; Sound
effects will have 2 streams and the sfx themselves will choose which
channel(s) they use.&#xA0; So 6 streams total that could potentially be
running at the same time.&#xA0; We will number them like this:<br><br><span style="font-family: Courier New;">MUSIC_SQ1 = $00 ;these are stream number constants</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">MUSIC_SQ2 = $01 ;stream number is used to index into stream variables (see below)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">MUSIC_TRI = $02</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">MUSIC_NOI = $03</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">SFX_1&#xA0;&#xA0;&#xA0;&#xA0; = $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">SFX_2&#xA0;&#xA0;&#xA0;&#xA0; = $05</span><br><br><br>Each
stream will need it&apos;s own variables in RAM.&#xA0; An easy way to organize
this is to reserve RAM space in blocks and use the stream number as an
index: <br><br><span style="font-family: Courier New;">;reserve 6 bytes each, one for each stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_curr_sound .rs 6&#xA0;&#xA0;&#xA0;&#xA0; ;what song/sfx # is this stream currently playing?&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_channel .rs 6&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;what channel is it playing on?</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_vol_duty .rs 6&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;volume/duty settings for this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_note_LO .rs 6&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;low 8 bits of period for the current note playing on the stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_note_HI .rs 6&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;high 3 bits of the note period</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;..etc</span><br><br>Here we have 6 bytes reserved for each variable.&#xA0; Each stream gets its own byte, for example:<br>&#xA0;&#xA0;&#xA0; stream_vol_duty+0:&#xA0; MUSIC_SQ1&apos;s volume/duty settings<br>&#xA0;&#xA0;&#xA0; stream_vol_duty+1:&#xA0; MUSIC_SQ2&apos;s volume/duty<br>&#xA0;&#xA0;&#xA0; stream_vol_duty+2:&#xA0; MUSIC_TRI&apos;s on/off<br>&#xA0;&#xA0;&#xA0; stream_vol_duty+3:&#xA0; MUSIC_NOI&apos;s volume<br>&#xA0;&#xA0;&#xA0; stream_vol_duty+4:&#xA0; SFX_1&apos;s volume/duty<br>&#xA0;&#xA0;&#xA0; stream_vol_duty+5:&#xA0; SFX_2&apos;s volume/duty<br>&#xA0;&#xA0; &#xA0;<br>In our sound_play_frame code we will loop through all of the streams using the stream number as an index:<br>&#xA0;&#xA0; &#xA0;<br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldx #$00&#xA0;&#xA0;&#xA0; ;start at stream 0 (MUSIC_SQ1)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;read from data stream in ROM if necessary</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;update stream variables based on what we read</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_vol_duty, x&#xA0; ;the value in x determines which stream we are working with</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do stuff with volume</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do stuff with note periods</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do more stuff with other variables</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inx&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;next stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpx #$06&#xA0;&#xA0;&#xA0; ;loop through all six streams</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .loop</span><br><br>The
music streams will always be running, updating the APU ports with their
data frame by frame.&#xA0; When a sound effect starts playing, one or both
of the sfx streams will start running.&#xA0; Because our loop processes the
SFX streams last, they will write to the APU last and thus overwrite
the shared-channel music streams.&#xA0; Our channel conflict is taken care
of automatically by the order of our loop!<br>&#xA0;&#xA0; &#xA0;<br><font size="4"><b>Music</b></font><br>We
now have an idea of how our stream data will be stored in RAM, but
there are still many unanswered questions.&#xA0; How do we load a song?&#xA0; How
do we know where to find the data streams in ROM?&#xA0; How do we read from
those data streams?&#xA0; How do we interpret what we read from those
streams?<br><br>To answer these questions, we need to make a data
format.&#xA0; Let&apos;s start with music.&#xA0; What should our music data look
like?&#xA0; Most NES music data is divided into three types:<br><br>1. <b>Note</b> - what note to play: A3, G#5, C2, etc<br>2. <b>Note Length</b> - how long to play the notes: eighth note, quarter note, whole note, etc<br>3. <b>Opcodes</b> - opcodes tell the engine to perform specific tasks: loop, adjust volume, change Duty Cycle for squares, etc<br>*3.5. <b>Arguments</b> - some opcodes will take arguments as input (e.g. how many times to loop, where to loop to).<br><br><b>Ranges</b><br>We
will need to design our data format to make it easy for the sound
engine to differentiate between these three types of data.&#xA0; We do this
by specifying ranges.&#xA0; For example, we might say that byte values of
$00-$7F represent Notes.&#xA0; $80-$9F are Note Lengths, and $A0-$FF are
opcodes.&#xA0; I just made those numbers up.&#xA0; It really doesn&apos;t matter what
values we use.&#xA0; The important thing is that we have ranges to test
against to determine whether a byte is a note, note length or opcode.&#xA0;
In our engine code we will have something like this:<br><br><span style="font-family: Courier New;">fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_pointer], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read a byte from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note Length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note stuff</span><br>&#xA0;&#xA0; &#xA0;<br>This
code reads a byte from the sound data and then tests that byte to see
which range it falls into.&#xA0; It jumps to a different section of code for
each possible range.&#xA0; Almost any data format you create will be divided
into ranges like this, whether it be sound data, map data, text data,
whatever.<br><br><b>BPL and BMI</b><br>These two branch instructions
are worth learning if you don&apos;t know them already.&#xA0; After BEQ, BNE, BCS
and BCC they are the most common branch instructions.&#xA0; They are often
used in range-testing.<br><br><b>BPL</b> tests the Negative (N) flag
and will branch if it is clear.&#xA0; Think of BPL as Branch if PLus.&#xA0; The N
flag will be clear if the last instruction executed resulted in a value
less than #$80 (ie, <i>bit7 clear</i>).<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #%01101011</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; |</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; +-------- bit7 is clear.&#xA0; This will clear the N flag.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .somewhere&#xA0; ;N flag is clear, so this will branch</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #%10010101</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; |</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; +-------- bit7 is set.&#xA0; This will set the N flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .somewhere&#xA0; ;N flag is set, so this will not branch.</span><br><br><b>BMI</b>
is the opposite.&#xA0; It tests the N flag and will branch if it is set.&#xA0;
Think of BMI as Branch if MInus.&#xA0; The N flag will be set if the last
instruction executed resulted in a value greater than or equal to #$80
(ie, <i>bit7 set</i>).<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #%01101011</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; |</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; +-------- bit7 is clear.&#xA0; This will clear the N flag.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bmi .somewhere&#xA0; ;N flag is clear, so this will not branch</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #%10010101</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; |</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; +-------- bit7 is set.&#xA0; This will set the N flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bmi .somewhere&#xA0; ;N flag is set, so this will branch to the label .somewhere.</span><br><br>In the range-testing code above, I used BPL to check if a byte fell into the Note range (00-7F).&#xA0; Go back and check it.<br><font size="4"><br>
<b>Song Headers</b></font><br>Music on the NES is typically composed of
four parts: a Square 1 part, a Square 2 part, a Triangle part and a
Noise part.&#xA0; When you want to play a song, you will have the main
program issue a command to the sound engine telling it what song you
want to play.&#xA0; It will look something like this:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$02</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr sound_load&#xA0; ;load song 2</span><br>&#xA0;&#xA0; &#xA0;<br>Somehow
our sound_load subroutine will have to take that &quot;2&quot; and translate it
into a whole song, complete with Square 1, Square 2, Triangle and Noise
parts.&#xA0; How does that little number become 4 streams of data?&#xA0; Well,
that number is an index into a pointer table, a table of pointers to
song headers.&#xA0; The song headers themselves will contain pointers to the
individual channels&apos; data streams.<br><br><font size="4"><b>Pointer Tables</b></font><br>A pointer table is a special kind of lookup table.&#xA0; Only instead of holding regular old numerical data a pointer table holds <b>addresses</b>.&#xA0;
These addresses &quot;point&quot; to the start of data.&#xA0; Addresses on the NES are
16-bit ($0000-$FFFF), so pointer tables are always tables of words.&#xA0;
Let&apos;s look at an example:<br><br><span style="font-family: Courier New;">pointer_table:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word $8000, $ABCD, $CC10, $DF1B</span><br>&#xA0;&#xA0; &#xA0;<br>Here
we have a pointer table.&#xA0; It&apos;s four entries long.&#xA0; Each entry is a
16-bit address.&#xA0; Presumably there is data at these four addresses that
we will want to read sometime in our program.&#xA0; To read this data we
will need to index into the pointer table, grab the address and store
it in a zero-page pointer variable and then read using indirect mode:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .rsset $0000</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">ptr1 .rs 2&#xA0; ;a 2-byte pointer variable.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;The first byte will hold the LO byte of an address</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;The second byte will hold the HI byte of an address</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .org $E000&#xA0; ;somewhere in ROM</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$02&#xA0;&#xA0;&#xA0; ;the third entry in the pointer table ($CC10)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2 because we are indexing into a table of words</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda pointer_table, y&#xA0;&#xA0;&#xA0; ;#$10 - little endian, so words are stored LO-byte first</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta ptr1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda pointer_table+1, y&#xA0; ;#$CC</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta ptr1+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;now our pointer is setup in ptr1.&#xA0; It &quot;points&quot; to address $CC10.&#xA0; Let&apos;s read data from there.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [ptr1], y&#xA0;&#xA0; ;indirect mode.&#xA0; reads the byte at $CC10</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta some_variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [ptr1], y&#xA0;&#xA0; ;reads the byte at $CC11</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta some_other_variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;... etc</span><br>&#xA0;&#xA0; &#xA0;<br>This
code takes an index and uses it to read an address from our
pointer_table.&#xA0; It stores this address in a variable called ptr1 (LO
byte first).&#xA0; Then it reads from this address by using indirect mode.&#xA0;
We specify indirect mode by putting []&apos;s around our pointer variable.&#xA0;
Look at this instruction: &#xA0;<br>&#xA0;&#xA0; &#xA0;<br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [ptr1], y</span><br style="font-family: Courier New;"><br>It means &quot;Find the address ptr1 is pointing to.&#xA0; Add Y to that address.&#xA0; Load the value at that address into A&quot;.<br><br>This
is very versatile because we can stick any address we want into our
ptr1 variable and read from anywhere!&#xA0; A pointer table is just a lookup
table of places we want to read from.<br><br>Of course you usually
won&apos;t know where exactly in the ROM your data will be.&#xA0; So instead of
declaring addresses explicitely ($8000, $ABCD, $CC10, etc), you will
use labels instead:<br><br><span style="font-family: Courier New;">pointer_table:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word data1, data2, data3&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;these entries will evaluate to the 16-bit addresses of the labels below</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">data1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $FF, $16, $82, $44&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;some random data</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">data2:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $0E, $EE, $EF, $16, $23</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">data3:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $00, $01</span><br>&#xA0;&#xA0;&#xA0; <br>
<b>Song Header Pointer Table</b><br>Our songs work the same way.&#xA0; When
the main program tells the sound engine to play a song, it will send
the song number with it.&#xA0; This song number is actually an index into a
pointer table of song headers:<br>&#xA0;&#xA0; &#xA0;<br><span style="font-family: Courier New;">song_headers:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song0_header</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song1_header</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song2_header</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;..etc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_load:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2.&#xA0; we are indexing into a table of pointers (words)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda song_headers, y&#xA0;&#xA0;&#xA0;&#xA0; ;read LO byte of a pointer from the pointer table.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;sound_ptr is a zero page pointer variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda song_headers+1, y&#xA0;&#xA0; ;read HI byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta some_variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;...read the rest of the header data</span><br>&#xA0;&#xA0; &#xA0;<br><font size="4"><b>Header Data</b></font><br>So what will our song header data look like?&#xA0; At the very least it should tell us:<br><br>How many data streams we have (songs will usually have 4, but sfx will have fewer)<br>Which streams those are (which stream index to use)<br>Which channels those streams use<br>Where to find those streams (ie, pointers to the beginning of each stream).<br>Initial values for those streams (for example, initial volume)<br><br>As
we add more features to our sound engine, we may expand our headers to
initialize those features.&#xA0; Let&apos;s start simple.&#xA0; Our headers will look
like this:<br><br><span style="font-family: Courier New;">main header:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">byte #&#xA0; | what it tells us</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | number of streams</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">01+&#xA0;&#xA0;&#xA0;&#xA0; | stream headers (one for each stream)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream headers:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">byte #&#xA0; | what it tells us</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | which stream (stream number)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | status byte (see below)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">02&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">03&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | initial volume (and duty for squares)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">04-05&#xA0;&#xA0; | pointer to data stream</span><br><br>The <b>status byte</b>
will be a bit-flag that tells us special information about the stream.&#xA0;
For now we will just use bit0 to mark a stream as enabled or disabled.&#xA0;
In the future we may use other bits to store other information, such as
stream priority.<br><br style="font-family: Courier New;"><b><span style="font-family: Courier New;">Stream Status Byte</span></b><br style="font-family: Courier New;"><span style="font-family: Courier New;">76543210</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; |</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; +- Enabled (0: stream disabled; 1: enabled)</span><br style="font-family: Courier New;"><br><br>
<b>Sample Header</b><br>Here is some code showing a sample header:<br><br><span style="font-family: Courier New;">SQUARE_1 = $00 ;these are channel constants</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">SQUARE_2 = $01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">TRIANGLE = $02</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">NOISE = $03</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">MUSIC_SQ1 = $00 ;these are stream # constants</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">MUSIC_SQ2 = $01 ;stream # is used to index into stream variables</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">MUSIC_TRI = $02</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">MUSIC_NOI = $03</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">SFX_1&#xA0;&#xA0;&#xA0;&#xA0; = $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">SFX_2&#xA0;&#xA0;&#xA0;&#xA0; = $05</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">song0_header:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $04&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;4 streams</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte MUSIC_SQ1&#xA0;&#xA0;&#xA0;&#xA0; ;which stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;status byte (stream enabled)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte SQUARE_1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $BC&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;initial volume (C) and duty (10)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song0_square1 ;pointer to stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte MUSIC_SQ2&#xA0;&#xA0;&#xA0;&#xA0; ;which stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;status byte (stream enabled)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte SQUARE_2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $38&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;initial volume (8) and duty (00)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song0_square2 ;pointer to stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte MUSIC_TRI&#xA0;&#xA0;&#xA0;&#xA0; ;which stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;status byte (stream enabled)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte TRIANGLE&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $81&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;initial volume (on)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song0_tri&#xA0;&#xA0;&#xA0;&#xA0; ;pointer to stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte MUSIC_NOI&#xA0;&#xA0;&#xA0;&#xA0; ;which stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;disabled.&#xA0; We will have our load routine skip the</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0;&#xA0; rest of the reads if the status byte disables the stream.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0;&#xA0; We are disabling Noise because we haven&apos;t covered it yet.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;"><br>
;these are the actual data streams that are pointed to in our stream headers. &#xA0;&#xA0; </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">song0_square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, C5, E5, A5 ;some notes.&#xA0; A minor</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">song0_square2:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, A3, A3, E4, A3, A3, E4 ;some notes to play on square 2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">song0_tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, A3, A3, A3, A3, A3, A3 ;triangle data</span><br>&#xA0;&#xA0; &#xA0;<br><b>Sound Engine Variables</b><br>The
last thing we need before we can write our sound_load routine is some
variables.&#xA0; As mentioned, our sound engine will have several streams
running simultaneously.&#xA0; Four will be used for music (one for each
tonal channel).&#xA0; Two will be used for sound effects.&#xA0; So we will
declare all variables in blocks of 6.&#xA0; Based on our header data, we
will need the following variables:<br><br><span style="font-family: Courier New;">stream_curr_sound .rs 6&#xA0;&#xA0;&#xA0;&#xA0; ;reserve 6 bytes, one for each stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_status .rs 6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_channel .rs 6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_vol_duty .rs 6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_ptr_LO .rs 6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_ptr_HI .rs 6</span><br><br><b>sound_load</b><br>Now
let&apos;s write some code to read our header.&#xA0; Pay special attention to the
X register.&#xA0; I recommend tracing through the code using the sample
header above.&#xA0; Here is our sound_load routine:<br><br><span style="font-family: Courier New;">;-------------------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">; load_sound will prepare the sound engine to play a song or sfx.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;&#xA0;&#xA0; input:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; A: song/sfx number to play</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_load:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save song number</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2.&#xA0; We are indexing into a table of pointers (words)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda song_headers, y&#xA0;&#xA0;&#xA0;&#xA0; ;setup the pointer to our song header</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda song_headers+1, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read the first byte: # streams</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_temp2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;store in a temp variable.&#xA0; We will use this as a loop counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;stream number</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tax&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;stream number acts as our variable index</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;status byte.&#xA0; 1= enable, 0=disable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .next_stream&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if status byte is 0, stream disabled, so we are done</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;channel number</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;initial duty and volume settings</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_vol_duty, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;pointer to stream data.&#xA0; Little endian, so low byte first</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.next_stream:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;song number</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_curr_sound, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dec sound_temp2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;our loop counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Now our sound_load routine is ready.&#xA0; If the main program calls it, like this:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00 ;song 0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr sound_load</span><br>&#xA0;&#xA0; &#xA0;<br>Our
sound_load routine will take the value in the A register and use it to
fill our music RAM with everything we need to get our song running!<br><br><b>Reading Streams</b><br>Once
we have our header loaded, we are ready to rock.&#xA0; All of our active
streams have pointers to their data stored in their stream_ptr_LO and
stream_ptr_HI variables.&#xA0; That&apos;s all we need to start reading data from
them.<br><br>To read data from our data stream, we will first copy the
stream pointer into a zero-page pointer variable.&#xA0; Then we will read a
byte using indirect mode and range-test it to determine whether it is a
note, note length or opcode.&#xA0; If it&apos;s a note, we will read from our
note_table and store the 11-bit period in RAM.&#xA0; Finally, we will update
our stream pointer to point to the next byte in the stream. &#xA0;<br><br>First we will need to declare some new variable blocks for the note periods:<br><br><span style="font-family: Courier New;">stream_note_LO .rs 6&#xA0;&#xA0;&#xA0; ;low 8 bits of period</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_note_HI .rs 6&#xA0;&#xA0;&#xA0; ;high 3 bits of period</span><br style="font-family: Courier New;"><br>Here is our se_fetch_byte routine (se_ stands for &quot;sound engine&quot;):<br><br><span style="font-family: Courier New;">;--------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">; se_fetch_byte reads one byte from a sound data stream and handles it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;&#xA0;&#xA0; input: </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; X: stream number</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x&#xA0;&#xA0;&#xA0; ;copy stream pointer into a zero page pointer variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read a byte using indirect mode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt;#$80, we have a note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt;#$A0 we have a note length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else we have an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;nothing here yet</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .update_pointer</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;nothing here yet</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .update_pointer</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2 because we are index into a table of words</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save our Y register because we are about to destroy it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table, y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;pull low 8-bits of period and store it in RAM</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table+1, y&#xA0;&#xA0;&#xA0;&#xA0; ;pull high 3-bits of period from our note table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;restore the Y register</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;;update our stream pointers to point to the next byte in the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;.update_pointer:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set index to the next byte in the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tya</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_ptr_LO, x&#xA0;&#xA0;&#xA0; ;add Y to the LO pointer</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .end</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inc stream_ptr_HI, x&#xA0;&#xA0;&#xA0; ;if there was a carry, add 1 to the HI pointer.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.end:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br><br>Look
at the part that updates the stream pointer.&#xA0;&#xA0; After we finish all our
reads, Y will hold the index of the last byte read.&#xA0; To be ready for
the next frame, we will want to update our pointer to point to the next
byte in the data stream.&#xA0; To do this, we increment Y and add it to the
pointer.&#xA0; But we have to be careful here.&#xA0; What if our current position
is something like this:<br><br>stream_ptr: $C3FF <br>Y: 1&#xA0;&#xA0; &#xA0;<br><br>The
next position here should be $C400.&#xA0; But ADC only works on the 8-bit
level, so if we add 1 to the low byte of the pointer we will get this
instead:<br><br>stream_ptr: $C300<br><br>The FF in the low byte becomes
00, but the high byte remains the same.&#xA0; We need to increment the high
byte manually.&#xA0; But how do we know when to increment it and when to
leave it alone?&#xA0; Lucky for us, ADC sets the carry flag whenever it
makes a FF-&gt;00 transition.&#xA0; So we can just check the carry flag
after our addition.&#xA0; If it is set, increment the high byte of the
pointer.&#xA0; If it is clear, don&apos;t increment it.&#xA0; That&apos;s what our code
above does.<br><br><font size="4"><b>Playing Music</b></font><br>We&apos;ve
loaded our header.&#xA0; We&apos;ve set up our stream pointers in RAM.&#xA0; We&apos;ve
written a routine that will read bytes from the streams and turn them
into notes.&#xA0; Now we need to update sound_play_frame.&#xA0; sound_play_frame
will loop through all 6 streams.&#xA0; It will check the status byte to see
if they are enabled.&#xA0; If enabled, it will advance the stream by one
frame.&#xA0; Here&apos;s the code:<br><br><span style="font-family: Courier New;">sound_play_frame:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_disable_flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .done&#xA0;&#xA0; ;if sound engine is disabled, don&apos;t advance a frame</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inc sound_frame_counter&#xA0;&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_frame_counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$08&#xA0;&#xA0;&#xA0; ;***change this compare value to make the notes play faster or slower***</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .done&#xA0;&#xA0; ;only take action once every 8 frames.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldx #$00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;our stream index.&#xA0; start at MUSIC_SQ1 stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x&#xA0;&#xA0;&#xA0; ;check bit 0 to see if stream is enabled</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #$01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .next_stream&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if disabled, skip to next stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_fetch_byte&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read from the stream and update RAM </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_set_apu&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;write volume/duty, sweep, and note periods of current stream to the APU ports</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.next_stream:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inx</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpx #$06&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;loop through all 6 streams.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_frame_counter ;reset frame counter so we can start counting to 8 again. &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br><br><br>And here is se_set_apu which will write a stream&apos;s data to the APU ports:<br>&#xA0;&#xA0; &#xA0;<br><span style="font-family: Courier New;">se_set_apu:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x&#xA0;&#xA0; ;which channel does this stream write to?</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 4 so Y will index into the right set of APU ports (see below)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_vol_duty, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4000, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4002, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4003, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #TRIANGLE</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcs .end&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if Triangle or Noise, skip this part</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$08&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else, set negate flag in sweep unit to allow low notes on Squares</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4001, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.end:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Writing to the APU ports directly like this is actually bad form.&#xA0; We&apos;ll learn why in a later lesson.<br><br>One
thing to pay attention to is how we get our APU port index.&#xA0; We take
the channel and multiply it by 4.&#xA0; Recall that we declared constants
for our channels:<br><br><span style="font-family: Courier New;">SQUARE_1 = $00 ;these are channel constants</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">SQUARE_2 = $01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">TRIANGLE = $02</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">NOISE = $03</span><br><br>If our stream_channel is $00 (SQUARE_1), we multiply by 4 to get $00.&#xA0; y = 0<br>&#xA0;&#xA0;&#xA0; $4000, y = $4000 &#xA0;<br>&#xA0;&#xA0;&#xA0; $4001, y = $4001 <br>&#xA0;&#xA0;&#xA0; $4002, y = $4002 <br>&#xA0;&#xA0;&#xA0; $4003, y = $4003<br>If our stream_channel is $01 (SQUARE_2), we multiply by 4 to get $04.&#xA0; y = 4<br>&#xA0;&#xA0;&#xA0; $4000, y = $4004 &#xA0;<br>&#xA0;&#xA0;&#xA0; $4001, y = $4005 &#xA0;<br>&#xA0;&#xA0;&#xA0; $4002, y = $4006<br>&#xA0;&#xA0;&#xA0; $4003, y = $4007 <br>If our stream_channel is $02 (TRIANGLE), we multiply by 4 to get $08.&#xA0; y = 8<br>&#xA0;&#xA0;&#xA0; $4000, y = $4008 &#xA0;<br>&#xA0;&#xA0;&#xA0; $4001, y = $4009 (unused) &#xA0;<br>&#xA0;&#xA0;&#xA0; $4002, y = $400A <br>&#xA0;&#xA0;&#xA0; $4003, y = $400B<br>If our stream_channel is $03 (NOISE), we multiply by 4 to get $0C.&#xA0; y = C<br>&#xA0;&#xA0;&#xA0; $4000, y = $400C &#xA0;<br>&#xA0;&#xA0;&#xA0; $4001, y = $400D &#xA0;<br>&#xA0;&#xA0;&#xA0; $4002, y = $400E<br>&#xA0;&#xA0;&#xA0; $4003, y = $400F<br>
<br>
See how everything lines up nicely?<br><br><b>Putting It All Together</b><br>Download and unzip the <a href="downloads/NerdyNightsSoundSourceCollection/headers.zip" target="_blank">headers.zip</a> sample files.&#xA0; Make sure the following files are in the same folder as NESASM3:<br><br>&#xA0;&#xA0;&#xA0; headers.asm<br>&#xA0;&#xA0;&#xA0; sound_engine.asm<br>&#xA0;&#xA0;&#xA0; headers.chr<br>&#xA0;&#xA0;&#xA0; note_table.i<br>&#xA0;&#xA0;&#xA0; song0.i<br>&#xA0;&#xA0;&#xA0; song1.i<br>&#xA0;&#xA0;&#xA0; song2.i<br>&#xA0;&#xA0;&#xA0; song3.i<br>&#xA0;&#xA0;&#xA0; headers.bat<br><br>Double click headers.bat. That will run NESASM3 and should produce the headers.nes file. Run that NES file in FCEUXD SP.<br><br>Use the controller to select songs and play them.&#xA0; Controls are as follows:<br>&#xA0;&#xA0; &#xA0;<br><b>Up</b>: Play<br><b>Down</b>: Stop <br><b>Right</b>: Next Song<br><b>Left</b>: Previous Song<br><br>Song0
is a silence song.&#xA0; It is not selectable.&#xA0; headers.asm &quot;plays&quot; song0 to
stop the music when you press down.&#xA0; See song0.i to find out how it
works.<br>Song1 is an evil sounding series of minor thirds.<br>Song2 is
a short sound effect on the Sq2 channel.&#xA0; It uses the SFX_1 stream.&#xA0;
Try playing it over the other songs to see how it steals the channel
from the music.<br>Song3 is a simple descending chord progression.<br><br>Try
creating your own songs and sound effects and add them into the mix.&#xA0;
To add a new song you will need to take the following steps:<br><br>1) create a song header and song data (use the included songs as reference).&#xA0; Note that data streams are terminated with $FF<br>2) add your header to the song_headers pointer table at the bottom of sound_engine.asm<br>3) update the constant NUM_SONGS to reflect the new song number total (also at the bottom of sound_engine.asm)<br><br>Although
not necessary, I recommend keeping your song data in a separate file
like I&apos;ve done with song0.i, song1.i, song2.i and song3.i.&#xA0; This makes
it easier to find the data if you need to edit your song later.&#xA0; If you
do this, don&apos;t forget to .include your file.<br><br><b>Next Week</b>: <a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=24885" target="_blank">Timing, Note Lengths, Buffering and Rests</a><br>
				