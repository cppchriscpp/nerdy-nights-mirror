<div class="mdl-card__title"><strong>Sumez</strong> posted on 
		
			
				
				Mar 8, 2018 at 4:46:58 AM 
			
			
			
			
		
	</div><div class="mdl-card__supporting-text">
					<div class="FTQUOTE"><i>Originally posted by: <b>brilliancenp</b></i><br>
<br>
I think this would work except the screen scrolls by 8 and the meta tiles are 16 wide, so how do&#xA0;we account for this?&#xA0;</div>
Shift your bits right until you get the correct index. Say you have the scroll index based on 8px blocks, shift your bits right once (which is the same as dividing by 2), you&apos;ll discard the least significant bit (which you don&apos;t need since two 8px blocks fit into one 16px block) and get a 16px index.<br>
Usually your scroll offset will be defined to the pixel though, since that&apos;s how the PPU uses it, so in that case you&apos;d shift that number right four times (1-&gt;2-&gt;4-&gt;8-&gt;16) to get a 16px index. This kind of operation is very common in 8bit assembly programming.<br>
Sorry if I misunderstood your question.<br>
<br>
&#xA0;
<div class="FTQUOTE" style="width: 932.797px;"><i>Originally posted by:&#xA0;<b>brilliancenp</b></i><br>
<br>
Has anyone figured out how to keep track of background collision when scrolling using background compression?&#xA0; Im&#xA0;not looking for a full solution but maybe a different way of thinking that might lead to the answer.&#xA0; I have been staring at this for a week now and am losing hope lol.&#xA0; Any help is greatly appreciated.</div>
There&apos;s no single correct way to do that, as it completely depends on the way you compress your stages. For crazy compression like SMB, where every part of the stage is generated by algorithms and prefabricated structures, you&apos;d have to decompress your stages data and copy the result into RAM, and read from that instead of ROM data. The problem is of course that the NES doesn&apos;t have a whole lot of RAM (unless you use extra RAM on the cartridge), so usually what you&apos;d do is only decompress the area right around the characters that need to check for background collisions.<br>
<br>
The simplest, most effective compression method I&apos;ve been using is simply using metatiles of metatiles. So similar to your 16px metatiles, you&apos;d have 32px metatiles of four 16px ones, and 64px metatiles of four 32px ones, making sure to reuse the same ones as much as possible and limiting yourself to 256 different metatiles of each type at most. That kind of compression allows me to decompress on the fly whenever I need a metatile index by using bit shifting similar to what I described above (shift your 16px index right once to get the 32px index, etc)
				</div><div class="mdl-card--border"></div>