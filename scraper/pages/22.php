
					<b>Last Week</b>: <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253">Volume Envelopes</a><br>
<br>
<b>This Week</b>: Opcodes and Looping<br>
<br>
<font size="5"><b>Opcodes</b></font><br>
<br>So far our sound engine handles two type of data that it reads from
music data streams: notes and note lengths.&#xA0; This is enough to write
complex music but of course we are going to want more features.&#xA0; We
will want control over the sound of our notes.&#xA0; What if we want to
change duty cycles midstream?&#xA0; Or volume envelopes?&#xA0; Or keys?&#xA0; What if
we want to loop one part of the song four times?&#xA0; Or loop the entire
song continuously?&#xA0; What if we want to play a sound effect as part of a
song?<br><br>All of these types of features, features where you are
issuing commands to the engine, are going to be done through opcodes
(also called control codes or command codes).&#xA0; An <b>opcode</b> is a
value in the data stream that tells the engine to run a specific,
specialized subroutine or piece of code.&#xA0; Most opcodes will have <b>arguments</b>
sent along with them.&#xA0; For example, an opcode that changes a stream&apos;s
volume envelope will come with an argument that specifies which volume
envelope to change to.<br><br>We&apos;ve actually been using an opcode for
weeks, I just haven&apos;t mentioned it.&#xA0; It&apos;s the opcode that ends a sound,
and we&apos;ve been encoding it in our data streams as $FF.&#xA0; Here is the
code we&apos;ve been using:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip--- (fetch a byte and range test)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$FF</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .end</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x&#xA0;&#xA0;&#xA0; ;if $FF, end of stream, so disable it and silence</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%11111110</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_status, x&#xA0;&#xA0;&#xA0; ;clear enable flag in status byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #TRIANGLE</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .silence_tri&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;triangle is silenced differently from squares and noise</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$30&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;squares and noise silenced with #$30</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .silence</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.silence_tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$80&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;triangle silenced with #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.silence:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_vol_duty, x&#xA0; ;store silence value in the stream&apos;s volume variable.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .update_pointer&#xA0;&#xA0;&#xA0;&#xA0; ;done</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip--- (do note lengths and notes, update the stream&apos;s pointer)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Here we check if the byte read has a value of $FF.&#xA0; If so we turn the stream off and silence it.&#xA0; That&apos;s an opcode.<br><br>It
would be pretty messy if every opcode we had was just written straight
out like this.&#xA0; Normally we would pull this code into its own
subroutine, like this:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip--- (fetch a byte and range test)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;end sound opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .end</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><span style="color: rgb(255, 0, 0); font-family: Courier New;">jsr se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;call the endsound subroutine</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .fetch&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;grab the next byte in the stream.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip--- (do note lengths and notes, update the stream&apos;s pointer)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_endsound:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x&#xA0;&#xA0;&#xA0; ;end of stream, so disable it and silence</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%11111110</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_status, x&#xA0;&#xA0;&#xA0; ;clear enable flag in status byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #TRIANGLE</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .silence_tri&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;triangle is silenced differently from squares and noise</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$30&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;squares and noise silenced with #$30</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .silence</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.silence_tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$80&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;triangle silenced with #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.silence:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_vol_duty, x&#xA0; ;store silence value in the stream&apos;s volume variable.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>The .opcode branch is much shorter now.&#xA0; If we wanted to add more opcodes, we could just add some more compares:<br><br><span style="font-family: Courier New;">.opcode:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;is it the end sound opcode? </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .not_FF</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">jsr se_op_endsound&#xA0; ;if so, call the end sound subroutine</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .end&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;and finish</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.not_FF:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$FE&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else is it the loop opcode?</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .not_FE</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">jsr se_op_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if so, call the loop subroutine</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .opcode_done</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.not_FE:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$FD&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else is it the change volume envelope opcode?</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .not_FD</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">jsr se_op_change_ve ;if so, call the change volume envelope subroutine</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .opcode_done</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.not_FD:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode_done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;update index to next byte in the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .fetch&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;go fetch another byte</span><br>&#xA0;&#xA0; &#xA0;<br><br>This
will work, but it&apos;s ugly.&#xA0; The more opcodes we add to our engine, the
more checks we need to make.&#xA0; What if we have 20 opcodes?&#xA0; Do we really
want to do that many compares?&#xA0; It&apos;s a waste of ROM space and cycles.<br><br><b>Tables</b><br>Anytime you find yourself in a situation where you are doing a lot of CMPs on one value, the answer is to use a <b>lookup tabl</b>e.&#xA0;
It will simplify everything!&#xA0; We&apos;ve done it already with notes, note
lengths, song numbers and volume envelopes.&#xA0; Could you imagine trying
to get a note&apos;s period without using the lookup table?&#xA0; It would look
like this:<br><br><span style="font-family: Courier New;">Is the note an A1?&#xA0; If so, use this period, else</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">Is the note an A#1?&#xA0; If so, use this period, else</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">Is the note a B1?&#xA0; If so, use this period, else</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">Is the note a C2?&#xA0; If so, use this period, else</span><br style="font-family: Courier New;"><b style="color: rgb(255, 0, 0);"><span style="font-family: Courier New;">... (about 100 more checks)</span></b><br style="font-family: Courier New;"><span style="font-family: Courier New;">Is the note an F#9? If so, use this period, else</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">Is the note a rest?&#xA0; If so, use this period</span><br><br>That&apos;s
just crazy.&#xA0; It would be hundreds of lines of unreadable code and you&apos;d
run into branch-range errors too.&#xA0; When we use a lookup table, the code
is simplified to this:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;save our index</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table+1, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;restore data stream index</span><br>&#xA0;&#xA0; &#xA0;<br>Much cleaner.&#xA0; Again, I can&apos;t stress it enough: <b>if you find yourself doing lots of CMPs on a single value, use a table instead!</b><br>&#xA0;&#xA0; &#xA0;<br>With notes and note lengths we used a straight <i>lookup table</i> of values.&#xA0; With song numbers and volume envelopes we used a special type of lookup table called a <i>pointer table</i>, which stored data addresses.&#xA0; For opcodes we have two choices.&#xA0; We can use something called a <b>jump table</b> or we can use an <b>RTS table</b>.&#xA0;
They are almost the same and the difference in performance between the
two methods is negligible so for most programmers it&apos;s a matter of
personal preference. &#xA0;<br><br>I prefer RTS tables myself, but we&apos;re going to use jump tables because they are easier to explain and understand.<br><br><b>Jump Tables</b><br>Ok,
here&apos;s our problem:&#xA0; Our sound engine has opcodes.&#xA0; A lot of them,
let&apos;s say 10 or more.&#xA0; Each opcode has its own subroutine.&#xA0; When our
sound engine reads an opcode byte from the data stream, we want to
avoid a long list of CMP and BNE instructions to select the right
subroutine.&#xA0; How do we do that?&#xA0;&#xA0; We use a jump table.<br><br>A jump
table is similar to a pointer table: it is a table of addresses.&#xA0; But
whereas a pointer table holds addresses that point to the start of
data, a <b>jump table</b> holds addresses that point to the start of <i>code</i> (ie, the start of subroutines).&#xA0; For example, suppose we have some subroutines:<br><br><span style="font-family: Courier New;">sub_a:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldx #$FF</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sub_b:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc #$03</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sub_c:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sec</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sbc #$03</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Here is how a jump table would look using these subroutines:<br><br><span style="font-family: Courier New;">sub_jump_table:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word sub_a, sub_b, sub_c</span><br>&#xA0;&#xA0; &#xA0;<br>Hey,
that&apos;s pretty easy.&#xA0; We just use the subroutine label and the assembler
will translate that into the address where the subroutine starts.&#xA0;
Let&apos;s make a jump table for our sound opcode subroutines:<br><br><span style="font-family: Courier New;">se_op_endsound:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_infinite_loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_change_ve:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;etc..&#xA0; more subroutines</span><br style="font-family: Courier New;"><br>
<span style="font-family: Courier New;">;this is our jump table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_infinite_loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;etc, one entry per subroutine</span><br>&#xA0;&#xA0; &#xA0;<br>Cool.&#xA0; We have a jump table now.&#xA0; So how do we use it?<br><br><b>Indirect Jumping</b><br>The 6502 let&apos;s us do some cool things.&#xA0; One of those things is called an indirect jump.&#xA0; An <b>indirect jump</b> let&apos;s you stick a destination address into a zero-page pointer variable and jump there.&#xA0; It works like this:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .rsset $0000</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;first declare a pointer variable somewhere in the zero-page</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">jmp_ptr .rs 2&#xA0; ;2 bytes because an address is always a word</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp [jmp_ptr] ;will jump to $8000</span><br>&#xA0;&#xA0; &#xA0;<br>Here we stick an address ($8000, lo byte first) into our <b>jmp_ptr</b> variable.&#xA0; Then we do an indirect jump by using the JMP instruction followed by a pointer variable in brackets:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp [jmp_ptr] ;indirect jump</span><br>&#xA0;&#xA0; &#xA0;<br>This
instruction translates into English as &quot;Jump to the address that is
stored in jmp_ptr and jmp_ptr+1&quot;.&#xA0; It&apos;s extrememly useful.&#xA0; We can
stick any address we want in there:<br>&#xA0;&#xA0; &#xA0;<br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$C0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp [jmp_ptr] ;will jump to $C000</span><br>&#xA0;&#xA0; &#xA0;<br>We could read an address from ROM and use that if we wanted to, for example our reset vector:<br>&#xA0;&#xA0; &#xA0;<br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda $FFFC</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda $FFFD</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp [jmp_ptr] ;will jump to our reset routine</span><br>&#xA0;&#xA0; &#xA0;<br>And we can use it in combination with our jump table:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_opcodes, y&#xA0;&#xA0;&#xA0; ;read low byte of address from jump table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_opcodes+1, y&#xA0; ;read high byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp [jmp_ptr]&#xA0;&#xA0; ;will jump to whatever address we pulled from the table.</span><br>&#xA0;&#xA0; &#xA0;<br>Pretty powerful.&#xA0; We can dynamically jump to any section of code we want!<br>&#xA0;&#xA0; &#xA0;<br><b>Implementation</b><br>So
we know how to build a jump table and we know how to do an indirect
jump.&#xA0; Let&apos;s tie it all together and stick it into our sound engine.&#xA0;
Let&apos;s start with <b>se_fetch_byte</b>.&#xA0; se_fetch_byte reads a byte
from the data stream and range-checks it to see if it is a note, note
length or opcode.&#xA0; Recall that notes have a byte range of $00-$7F.&#xA0;
Note lengths have a range of $80-$9F.&#xA0; The opcode byte range is $A0-$FF:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; </span><span style="color: rgb(255, 0, 0); font-family: Courier New;">;else ($A0-$FF) it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note stuff</span><br>&#xA0;&#xA0; &#xA0;<br>So
we need to assign our opcodes to values between $A0 and $FF.&#xA0; Just as
with notes and note lengths, the opcode byte we read from the data
stream will be used as a table index (after subtracting $A0), so we
will assign our opcodes in the same order as our table:<br><br><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this should be $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_infinite_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this should be $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this should be $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;etc, 1 entry per subroutine</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">;these are aliases to use in the sound data.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">endsound = $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop = $A1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;be careful of conflicts here.&#xA0; this might be too generic.&#xA0; maybe song_loop is better</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">volume_envelope = $A2</span><br><br>Now let&apos;s alter se_fetch_byte to take care of our opcodes:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.fetch:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else ($A0-$FF) it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">;do Opcode stuff</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; jsr se_opcode_launcher&#xA0;&#xA0; ;launch our opcode!!!</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;next position in the data stream</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; and #%00000001</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .fetch&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;after our opcode is done, grab another byte unless the stream is disabled</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; rts&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; in which case we quit&#xA0; (explained below)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note stuff</span><br>&#xA0;&#xA0; &#xA0;<br>I
added a call to a subroutine called se_opcode_launcher and a little
branch.&#xA0; Not a big change is it?&#xA0; But there&apos;s an important detail
here.&#xA0; se_opcode_launcher will be a short, simple subroutine that will
read from the jump table and perform an indirect jump.&#xA0; It looks like
this:<br><br><span style="font-family: Courier New;">se_opcode_launcher:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save y register, because we are about to destroy it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sec</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sbc #$A0&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;turn our opcode byte into a table index by subtracting $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0;&#xA0; $A0-&gt;$00, $A1-&gt;$01, $A2-&gt;$02, etc.&#xA0; Tables index from $00.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;multiply by 2 because we index into a table of addresses (words)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_opcodes, y&#xA0;&#xA0;&#xA0; ;get low byte of subroutine address</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_opcodes+1, y&#xA0; ;get high byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta jmp_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;restore our y register</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set to next position in data stream (assume an argument)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp [jmp_ptr]&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;indirect jump to our opcode subroutine</span><br>&#xA0;&#xA0; &#xA0;<br>Short
and simple.&#xA0; So why did I wrap this code in its own subroutine?&#xA0; Why
not just stick this code as-is in the .opcode branch of se_fetch_byte?&#xA0;
Because we need a place to return to.<br><br>The JSR and RTS
instructions work as a pair.&#xA0; They go hand in hand.&#xA0; They need each
other.&#xA0; Without going into too much detail, this is what goes on behind
the scenes:<br>
<br>
<b>JSR</b> sticks a return address on the stack and jumps to a
subroutine.&#xA0; One way to look at it is to think of JSR as a JMP that
remembers where it started from.<br>
<b>RTS</b> pops the return address off the stack and jumps there.&#xA0; <br>
<br>
So JSR leaves a treasure map for RTS to pick up and follow later.&#xA0; The <b>key point</b> here is that <b>RTS expects a return address to be waiting for it on the stack</b>. &#xA0;<br><br>Now our opcode subroutines all end in an RTS instruction.&#xA0; Do you see the potential problem here?<br><br>We
call our opcode subroutines using an indirect jump.&#xA0; This requires us
to use a JMP instruction, not a JSR instruction.&#xA0; A JMP instruction
doesn&apos;t remember where it started from.&#xA0; No return address is pushed
onto the stack with a JMP instruction.&#xA0; So when we jump to our opcode
subroutine and hit the RTS instruction at the end, there is no return
address waiting for us!&#xA0; The RTS will pull whatever random values
happen to be on the stack at the time and jump there.&#xA0; We&apos;ll end up
somewhere random and our program will surely crash!<br><br>To fix this,
we wrap our indirect jump in a subroutine, se_opcode_launcher.&#xA0; We call
it with a JSR instruction, completing the JSR/RTS pair:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_opcode_launcher&#xA0; ;this jsr will let us remember where we came from</span><br>&#xA0;&#xA0; &#xA0;<br>This
JSR instruction will stick a return address on the stack for us.&#xA0; Then
inside se_opcode_launcher we perform our indirect jump to our desired
opcode subroutine.&#xA0; Now when we hit that RTS instruction at the end of
the opcode subroutine we have a return address waiting for us on the
stack.&#xA0; Our program returns back to where we started.&#xA0; We are safe.<br><font size="4"><b><br>
Opcode Subroutines</b></font><br>With our opcode launcher written, we are all set up to make opcodes.&#xA0; We already have one written: the <b>endsound</b>
opcode.&#xA0; This is the opcode we will use to terminate sound effects.&#xA0;
Sound effects don&apos;t loop continuously like songs do, so they need to be
stopped.&#xA0; Let&apos;s take a look again:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_endsound:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x&#xA0;&#xA0;&#xA0; ;end of stream, so disable it and silence</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%11111110</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_status, x&#xA0;&#xA0;&#xA0; ;clear enable flag in status byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #TRIANGLE</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .silence_tri&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;triangle is silenced differently from squares and noise</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$30&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;squares and noise silenced with #$30</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .silence&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; (this will always branch.&#xA0; bne is cheaper than a jmp)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.silence_tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$80&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;triangle silenced with #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.silence:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_vol_duty, x&#xA0; ;store silence value in the stream&apos;s volume variable.</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>This opcode is special.&#xA0; It&apos;s the reason for the check after the call to se_opcode_launcher:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip---</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else ($A0-$FF) it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_opcode_launcher</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;next position in the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">lda stream_status, x</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; and #%00000001</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .fetch&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;after our opcode is done, grab another byte unless the stream is disabled</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; rts&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; in which case we quit&#xA0; (explained below)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip---</span><br>&#xA0;&#xA0; &#xA0;<br>Normally,
we want se_fetch_byte to keep fetching bytes until it hits a note.&#xA0;
Recall that with note lengths we jumped back to .fetch after setting
the new note length.&#xA0; This is because after setting the length of the
note, we needed to know WHAT note to play.&#xA0; So we fetch another byte.&#xA0;
The same thing is true of opcodes.&#xA0; If we change the volume envelope
with an opcode, great!&#xA0; But we still need to know what note to play
next.&#xA0; If we use an opcode to switch our square&apos;s duty cycle, great!&#xA0;
But we still need to know what note to play next.&#xA0; If we use an opcode
to loop back to the beginning of the song, that&apos;s great!&#xA0; But we still
need to read that first note of the song.&#xA0; This is why we jump back to
fetch a byte after we run an opcode.<br><br>The ONE exception to this
rule is when we end a sound effect.&#xA0; We are terminating the sound
effect completely, so there is no next note.&#xA0; We don&apos;t want to fetch
something that isn&apos;t there, so we need to skip the jump.&#xA0; That&apos;s why we
check the status byte after we run the opcode.&#xA0; If the stream is
disabled by the endsound opcode, we are finished.&#xA0; Otherwise, fetch
another byte.<br><br><b>Looping</b><br>The next opcode in our list is the <b>loop</b>
opcode.&#xA0; This is the opcode that we will stick at the end of every song
to tell the sound engine to play the song again, and again and again.&#xA0;
It is actually quite easy to implement.&#xA0; It takes a <b>2-byte argument</b>, which is <b>the address to loop back to</b>.&#xA0; The subroutine looks like this:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_infinite_loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read LO byte of the address argument from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x&#xA0;&#xA0;&#xA0; ;save as our new data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read HI byte of the address argument from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_HI, x&#xA0;&#xA0;&#xA0; ;save as our new data stream position data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;update the pointer to reflect the new position.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;after opcodes return, we do an iny.&#xA0; Since we reset &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the stream buffer position, we will want y to start out at 0 again.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>The
first thing to notice about this subroutine is that it reads two bytes
from the data stream.&#xA0; This is the address argument that gets passed
along with the opcode.&#xA0; To make it clear, let&apos;s look at some example
sound data:<br><br><span style="font-family: Courier New;">song1_square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth ;set note length to eighth notes</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C5, E5, G5, C6, E6, G6, C5, Eb5, G5, C6, Eb6, half, G6 ;play some notes</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.byte loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this alias evaluates to $A1, the loop opcode</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .word song1_square1 ;this evaluates to the address of the song1_square1 label</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;ie, the address we want to loop to.</span><br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;<br>After
the &quot;loop&quot; opcode comes a word which is the address to loop back to.&#xA0;
In this example I chose to loop back to the beginning of the stream
data.<br><br>So what does our loop opcode do?&#xA0; It reads the first byte
of this address argument (the low byte) and stores it in
stream_ptr_LO.&#xA0; Then it reads the second byte of the address argument
(the high byte) and stores it in stream_ptr_HI.&#xA0; These are the
variables that keep track of our data stream position!&#xA0; The loop opcode
just changes these values to some address that we specify.&#xA0; Not too
complicated at all.&#xA0; The last step is to update the actual pointer (<b>sound_ptr</b>) so that the next byte we read from the data stream will be the first note we looped back to.<br><br>In
the example sound data above I looped back to the beginning of the
stream data, but there&apos;s nothing stopping me from looping somewhere
else:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">song1_square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">;intro, don&apos;t loop this part</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte quarter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C4, C4, C4, C4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;"><span style="color: rgb(255, 0, 0);">.loop_point:</span>&#xA0;&#xA0;&#xA0; ;this is where we will loop back to.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth ;set note length to eighth notes</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C5, E5, G5, C6, E6, G6, C5, Eb5, G5, C6, Eb6, half, G6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.byte loop</span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this alias evaluates to $A1, the loop opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.word .loop_point</span> ;this evaluates to the address of the .loop_point label</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;ie, the address we want to loop to.</span><br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;<br>Technically
we can also &quot;loop&quot; to a forward position, in which case it&apos;s actually
more like a jump than a loop.&#xA0; That&apos;s all a loop is really: a jump...
backwards.<br><br><b>Changing Volume Envelopes</b><br>Let&apos;s write the opcode subroutine to change volume envelopes.&#xA0; This one is even easier.&#xA0; It takes <b>one argument</b>, which will be <b>which volume envelope to switch to</b>:<br><br><span style="font-family: Courier New;">se_op_change_ve:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read the argument</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ve, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;store it in our volume envelope variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ve_index, x&#xA0; ;reset volume envelope index to the beginning</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>That&apos;s it!<br><br><b>Changing Duty Cycles</b><br>Now let&apos;s add an opcode that will change the duty cycle for a square stream.&#xA0; This one also takes <b>one argument: which duty cycle to switch to</b>.<br><br><span style="font-family: Courier New;">se_op_duty:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read the argument (which duty cycle to change to)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_vol_duty, x&#xA0; ;store it.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Done!&#xA0; Now we have the subroutine, but we still need to add it to our jump table:<br><br><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this should be $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this should be $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this should be $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .word se_op_duty&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this should be $A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;etc, 1 entry per subroutine</span><br><br><span style="font-family: Courier New;">;these are aliases to use in the sound data.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">endsound = $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop = $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">volume_envelope = $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">duty = $A3</span><br><br>And it&apos;s ready to use:<br><br><span style="font-family: Courier New;">song0_square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;intro, don&apos;t loop this part</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte quarter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C4, C4, C4, C4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop_point:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this is where we will loop back to.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.byte duty, $B0</span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;change the duty cycle</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.byte volume_envelope, ve_blip_echo</span> ;change the volume envelope</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set note length to eighth notes</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C5, E5, G5, C6, E6, G6&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;play some notes</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.byte duty, $30&#xA0;</span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;change the duty cycle</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.byte volume_envelope, ve_short_staccato</span>&#xA0;&#xA0;&#xA0; ;change volume envelope</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C5, Eb5, G5, C6, Eb6, half, G6&#xA0;&#xA0;&#xA0; ;play some eighth notes and a half note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;loop to .loop_point </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word .loop_point</span><br>&#xA0;&#xA0; &#xA0;<br><b>Readability</b><br>sound_engine.asm
is getting pretty bulky with all these subroutines.&#xA0; It will only get
bigger as we add more opcodes.&#xA0; It&apos;s nice to have all of our opcodes
together in one place, but it&apos;s annoying to have to scroll around to
find them.&#xA0; So let&apos;s pull all of our opcodes into their own file: <b>sound_opcodes.asm</b>.&#xA0; Then, at the bottom of sound_engine.asm, we can .include it:<br><br>&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.include &quot;sound_opcodes.asm&quot;</span> ;our opcode subroutines, jump table and aliases<br>&#xA0;&#xA0;&#xA0; .include &quot;note_table.i&quot; ;period lookup table for notes<br>&#xA0;&#xA0;&#xA0; .include &quot;note_length_table.i&quot;<br>&#xA0;&#xA0;&#xA0; .include &quot;vol_envelopes.i&quot;<br>&#xA0;&#xA0;&#xA0; .include &quot;song0.i&quot;&#xA0; ;holds the data for song 0 (header and data streams)<br>&#xA0;&#xA0;&#xA0; .include &quot;song1.i&quot;&#xA0; ;holds the data for song 1<br>&#xA0;&#xA0;&#xA0; .include &quot;song2.i&quot;<br>&#xA0;&#xA0;&#xA0; .include &quot;song3.i&quot;<br>&#xA0;&#xA0;&#xA0; .include &quot;song4.i&quot;<br>&#xA0;&#xA0;&#xA0; .include &quot;song5.i&quot;<br>&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.include &quot;song6.i&quot;</span>&#xA0; ;oooh.. new song!<br>&#xA0;&#xA0; &#xA0;<br>I
gave it the extension .asm because it contains code as well as data,
and I like to be able to tell at a glance what files have what in
them.&#xA0; Now whenever we want to add new opcodes, or tweak old ones, we
have them nice and compact in their own file.<br><br><b>Updating Sound Data</b><br>Whenever
we add new things to our sound engine, we have to think about how it
will affect our old sound data.&#xA0; This week we added opcodes, which will
change our songs and sound effects terminate.&#xA0; Before we were
terminating them with $FF.&#xA0; This won&apos;t work anymore because $FF doesn&apos;t
do anything.&#xA0; For songs, we should terminate with &quot;loop&quot; followed by an
address to loop to.&#xA0; With sound effects we should terminate with the
opcode &quot;endsound&quot;.&#xA0; See the included songs and sound effects for
examples.<br><br><b>RTS Tables</b><br>We talked about jump tables and
indirect jumping this week.&#xA0; Another method for doing the same thing
involves something called an <b>RTS table</b> and the <b>RTS Trick</b>.&#xA0;
I won&apos;t cover it in these tutorials, but if you are curious to know how
this works you can read <a href="http://wiki.nesdev.com/w/index.php/RTS_Trick" target="_blank" original-href="http://wiki.nesdev.com/w/index.php/RTS_Trick">this nesdev wiki article I wrote about the RTS
Trick</a>.<br><br><br><b>Putting It All Together</b><br>Download and unzip the <a href="downloads/NerdyNightsSoundSourceCollection/opcodes.zip" target="_blank" original-href="http://tummaigames.com/opcodes.zip">opcodes.zip</a> sample files.&#xA0; Make sure the following files are in the same folder as NESASM3:<br><br>&#xA0;&#xA0;&#xA0; opcodes.asm<br>&#xA0;&#xA0;&#xA0; sound_engine.asm<br>&#xA0;&#xA0;&#xA0; sound_opcodes.asm<br>&#xA0;&#xA0;&#xA0; opcodes.chr<br>&#xA0;&#xA0;&#xA0; note_table.i<br>&#xA0;&#xA0;&#xA0; note_length_table.i<br>&#xA0;&#xA0;&#xA0; vol_envelopes.i<br>&#xA0;&#xA0;&#xA0; song0.i<br>&#xA0;&#xA0;&#xA0; song1.i<br>&#xA0;&#xA0;&#xA0; song2.i<br>&#xA0;&#xA0;&#xA0; song3.i<br>&#xA0;&#xA0;&#xA0; song4.i<br>&#xA0;&#xA0;&#xA0; song5.i<br>&#xA0;&#xA0;&#xA0; song6.i<br>&#xA0;&#xA0;&#xA0; opcodes.bat<br><br>Double click opcodes.bat. That will run NESASM3 and should produce the opcodes.nes file. Run that NES file in FCEUXD SP.<br><br>Use the controller to select songs and play them.&#xA0; Controls are as follows:<br>&#xA0;&#xA0; &#xA0;<br><b>Up</b>: Play<br><b>Down</b>: Stop <br><b>Right</b>: Next Song/SFX<br><b>Left</b>: Previous Song/SFX<br><br>Song0 is a silence song.&#xA0; Not selectable.<br>Song1 is a boss song from The Guardian Legend.&#xA0; Now it loops!<br>Song2 is the same short sound effect from last week.&#xA0; Terminated with endsound.<br>Song3 is a song from Dragon Warrior.&#xA0; Now it loops!<br>Song4 is the same song4 as last week, but now it loops!<br>Song5 is a short sound effect, terminated with the endsound opcode.<br>Song6
should be familiar to readers of this forum.&#xA0; Do you recognize it?&#xA0; It
utilizes opcodes for changing duty cycles and volume envelopes.&#xA0; Plus
it loops!<br><br>Try adding your own songs and sound effects in.&#xA0; Try to add your own opcodes too.&#xA0; Here&apos;s some ideas for opcodes:<br><br>1. Trigger a sound effect mid-song<br>2. Implement duty cycle envelopes (similar to volume envelopes).&#xA0; Then make an opcode that allows you to change it.<br>3. Finite loops<br><br><b>Next Week</b>: <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247">more opcode fun.&#xA0; Finite Loops, Changing Keys and Autom...</a> .<br>
				