
					<b>Last Week</b>: <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247" target="_blank">Finite Looping, Key Changes, Chord Progressions</a><br><b><br>
This Week</b>: Simple Drums<br><br><font size="5"><b>Drums</b></font><br>This week we are going to take a look at drums.&#xA0; I saved them until now because they use the <b>Noise</b>
channel, which operates much differently from the other 3 channels.&#xA0;
With the Square and Triangle channels we manually set the waveform
period to choose what note to play.&#xA0; Our note lookup table was just a
table of periods to plug into the channel ports.&#xA0; The Noise channel on
the other hand produces random noise.&#xA0; We don&apos;t use a note table at all.<br><br><font size="3"><b>Noise Channel</b></font><br>The noise channel doesn&apos;t produce notes, it produces noise.&#xA0; We communicate with the noise channel through 3 ports: <b>$400C</b>, <b>$400E</b>, <b>$400F</b>.&#xA0; Note that port $400D is <i>unused</i>.&#xA0; Let&apos;s take a closer look at the Noise ports.<br><br><b>Volume - $400C</b><br>$400C let&apos;s you control the volume of the Noise channel.&#xA0; It works just like the Square channels, except there is no Duty Cycle:<br><br><span style="font-family: Courier New;">NOI_ENV ($400C)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">76543210</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0; ||||||</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0; ||++++- Volume</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0; |+----- Saw Envelope Disable (0: use internal counter for volume; 1: use Volume for volume)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0; +------ Length Counter Disable (0: use Length Counter; 1: disable Length Counter)</span><br>&#xA0; <br>For
our purposes, we will set Saw Envelope Disable and Length Counter
Disable and forget about them.&#xA0; This will allow us to have full control
of &quot;note&quot; length and volume via Volume Envelopes.&#xA0; We did the same
thing for the Square channels.<br><br><b>Random Generator - $400E</b><br>$400E let&apos;s us control the settings for the random generator.&#xA0; It looks like this:<br><br><span style="font-family: Courier New;">NOI_RAND ($400E)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">76543210</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">|&#xA0;&#xA0; ||||</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">|&#xA0;&#xA0; ++++- Sound Type</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">+-------- Mode</span><br><br><b>Mode</b> sets the mode.&#xA0; There are two modes, <b>Mode-0</b> and <b>Mode-1</b>.&#xA0;
Mode-0 sounds dull and breathy, like static sssh.&#xA0; Mode-1 sounds more
sharp, robotic and buzzy.&#xA0; There&apos;s really no good way to describe in
words, so the best way to know the difference in sound is to listen to
both modes.&#xA0; (see below)<br><br>Each mode has 16 possible sounds, selected by <b>Sound Type</b>.&#xA0;
This means that the Noise channel really only gives us 32 possible
sounds total!&#xA0; More complex sound effects on the Noise channel are
created by playing combinations of these 32 noises one after another.&#xA0;
To hear what each of the 32 sounds sound like, listen to <b>Song 8</b> in this week&apos;s sample program.&#xA0; It plays the 16 Mode-0 sounds followed by the 16 Mode-1 sounds.<br><br>Note:
In this tutorial I will assign each of the 32 Noise channel sounds a
number 00-1F.&#xA0; The left number (0 or 1) refers to the <i>Mode</i>.&#xA0; The right number (0-F) refers to the <i>Sound Type</i>.&#xA0; For example, sound &quot;04&quot; means &quot;Mode 0, Sound Type 4&quot;.&#xA0; Sound &quot;1E&quot; means &quot;Mode 1, Sound Type E&quot;.<br><br><b>Length Counter - $400F</b><br>$400F is the Noise channel&apos;s length counter.&#xA0; We disabled the length counter in $400C, so we can ignore this port completely!<br><font size="3"><b><br>
Simple Noise Drums<br>
</b></font><br>The simplest way to make a drum sound on the Noise
channel is to play a single Sound Type under a volume envelope that
decays to 0 (silence).&#xA0; Many games use this kind of drum exclusively.&#xA0;
The Guardian Legend for example only uses two drum sounds throughout
the whole game: 04 and 06.&#xA0; Battle Kid makes heavy use this simple drum
style too.&#xA0; Lots of games do.<br><br>So how will we represent simple
drums in the sound data?&#xA0; Recall that our sound engine distinguishes
between Notes, Note Lengths and Opcodes using ranges:<br><br><span style="font-family: Courier New;">.fetch:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;<span style="color: rgb(255, 0, 0);">range A0-FF</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;<span style="color: rgb(255, 0, 0);">range 80-9F</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;<span style="color: rgb(255, 0, 0);">range 00-7F</span></span><br>&#xA0;&#xA0; &#xA0;<br>Although
we won&apos;t use our note table for the Noise channel, we will treat drums
like notes as far as ranges are concerned.&#xA0; So we need our drum data
values to be in the range of $00-$7F.&#xA0; That&apos;s easy.&#xA0; We&apos;ll assign the
Mode-0 sounds to $00-$0F and Mode-1 sounds to $10-$1F.&#xA0; Some drum data
might look like this then:<br><br><span style="font-family: Courier New;">example_drum_data:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte sixteenth, $1E, $1E, $1F</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte d_eighth, $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte sixteenth, $06, $06, $08, $08</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, $17, $07</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word example_drum_data</span><br><br><br>Since
we are not using the note table for Noise, we will need to alter our
Note code to check the channel and branch to different code if we are
processing the Noise channel (new stuff in red):<br><br><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">sta sound_temp2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save the note value</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda stream_channel, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;what channel are we using?</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; cmp #NOISE&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;is it the Noise channel?</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .not_noise&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; jsr se_do_noise&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if so, JSR to a subroutine to handle noise data</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; jmp .reset_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;and skip the note table when we return</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">.not_noise:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else grab a period from the note_table</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda sound_temp2&#xA0;&#xA0;&#xA0;&#xA0; ;restore note value</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;save our index into the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_note_offset, x&#xA0;&#xA0; ;add note offset</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table+1, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;restore data stream index</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;check if it&apos;s a rest and modify the status flag appropriately</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_check_rest</span><br style="font-family: Courier New;"><span style="font-family: Courier New;"><span style="color: rgb(255, 0, 0);">.reset_ve:</span>&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ve_index, x &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.update_pointer:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tya</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .end</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inc stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.end:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>This
code checks to see if the channel is the Noise channel.&#xA0; If so it JSRs
to a special Noise subroutine.&#xA0; Upon return, it jumps over the
note_table code and updates the volume envelope and stream pointer like
normal.<br><br>So what does our special Noise subroutine, <span style="font-family: Courier New;">se_do_noise</span>, look like?&#xA0; The job of <span style="font-family: Courier New;">se_do_noise</span>
will be to take the note value and convert it into something we can
write to $400E (NOI_RAND).&#xA0; Recall that $400E expects the Mode number
in bit7 and the Sound Type in bits 0-3:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">NOI_RAND ($400E)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">76543210</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">|&#xA0;&#xA0; ||||</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">|&#xA0;&#xA0; ++++- Sound Type</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">+-------- Mode</span><br><br><b>Mode-0</b>
sounds don&apos;t need to be converted at all.&#xA0; We represent them with the
values $00-$0F, which correspond exactly to the values we need to write
to $400E.<br><br><b>Mode-1</b> sounds need to be tweaked a bit.&#xA0; We
represent Mode-1 sounds with the values $10-$1F, or in binary
%00010000-%00011111.&#xA0; Notice we identify the Mode number using bit4.&#xA0;
Port $400E expects the Mode number in bit7 though, not bit4, so we will
need to set bit7 ourselves:<br><br><span style="font-family: Courier New;">se_do_noise:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_temp2&#xA0;&#xA0;&#xA0;&#xA0; ;restore the note value</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%00010000&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;isolate bit4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .mode0&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if it&apos;s clear, Mode-0, so no conversion</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.mode1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_temp2&#xA0;&#xA0;&#xA0;&#xA0; ;else Mode-1, restore the note value</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ora #%10000000&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set bit 7 to set Mode-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_temp2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.mode0:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_temp2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_LO, x&#xA0;&#xA0; ;temporary port that gets copied to $400E</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Now everything is set.&#xA0; Note values of $00-$0F will get written to <span style="font-family: Courier New;">stream_note_LO</span> directly.&#xA0; Note values of $10-$1F will get converted to $90-$9F first and then get written to <span style="font-family: Courier New;">stream_note_LO</span>.&#xA0; Note that we do not bother clearing bit4 for Mode-1 sounds.&#xA0; Bit4 has no effect on $400E so we can just leave it as it is.<br><br><font size="3"><b>Drum Decay</b></font><br>The only thing left to add is a volume envelope for the simple drums to use.&#xA0; It should be short and decay to zero (silence):<br><br>volume_envelopes:<br>&#xA0;&#xA0;&#xA0; .word se_ve_1<br>&#xA0;&#xA0;&#xA0; .word se_ve_2<br>&#xA0;&#xA0;&#xA0; .word se_ve_3<br>&#xA0;&#xA0;&#xA0; .word se_ve_tgl_1<br>&#xA0;&#xA0;&#xA0; .word se_ve_tgl_2<br>&#xA0;&#xA0;&#xA0; .word se_battlekid_loud<br>&#xA0;&#xA0;&#xA0; .word se_battlekid_loud_long<br>&#xA0;&#xA0;&#xA0; .word se_battlekid_soft<br>&#xA0;&#xA0;&#xA0; .word se_battlekid_soft_long<br>&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.word se_drum_decay</span><br>&#xA0;&#xA0; &#xA0;<br><span style="color: rgb(255, 0, 0);">se_drum_decay:</span><br style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .byte $0E, $09, $08, $06, $04, $03, $02, $01, $00&#xA0; ;7 frames per drum.&#xA0; Experiment to get the length and attack you want.</span><br style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .byte $FF</span><br>&#xA0;&#xA0; &#xA0;<br><span style="color: rgb(255, 0, 0);">ve_drum_decay = $09</span><br style="color: rgb(255, 0, 0);"><br>You can of course make multiple volume envelopes for the drums to choose from.<br><br><font size="3"><b>Conclusion</b></font><br><br>Now we can add drum data to our songs.&#xA0; Here is the drum data for The Guardian Legend boss song we&apos;ve been using:<br><br><span style="font-family: Courier New;">;in the song header, after the header info for Squares and Triangle:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte MUSIC_NOI&#xA0;&#xA0;&#xA0;&#xA0; ;which stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;status byte: enabled</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte NOISE&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $30&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;initial volume_duty value (disable length counter and saw envelope)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte ve_drum_decay ;volume envelope</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song1_noise&#xA0;&#xA0; ;pointer to the sound data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $53&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;tempo</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">song1_noise:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, $04&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this song only uses drum 04 (Mode-0, Sound Type 4) for a snare</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte sixteenth, $04, $04, $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte d_eighth, $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte sixteenth, $04, $04, $04, $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, $04, $04</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song1_noise</span><br>&#xA0;&#xA0; &#xA0;<br>Try adding some drums to your own songs!<br>&#xA0;&#xA0; &#xA0;<br><b>Putting It All Together</b><br>Download and unzip the <a href="downloads/NerdyNightsSoundSourceCollection/drums.zip" target="_blank">drums.zip</a> sample files.&#xA0; Make sure the following files are in the same folder as NESASM3:<br><br>&#xA0;&#xA0;&#xA0; drums.asm<br>&#xA0;&#xA0;&#xA0; sound_engine.asm<br>&#xA0;&#xA0;&#xA0; sound_opcodes.asm<br>&#xA0;&#xA0;&#xA0; drums.chr<br>&#xA0;&#xA0;&#xA0; note_table.i<br>&#xA0;&#xA0;&#xA0; note_length_table.i<br>&#xA0;&#xA0;&#xA0; vol_envelopes.i<br>&#xA0;&#xA0;&#xA0; song0.i<br>&#xA0;&#xA0;&#xA0; song1.i<br>&#xA0;&#xA0;&#xA0; song2.i<br>&#xA0;&#xA0;&#xA0; song3.i<br>&#xA0;&#xA0;&#xA0; song4.i<br>&#xA0;&#xA0;&#xA0; song5.i<br>&#xA0;&#xA0;&#xA0; song6.i<br>&#xA0;&#xA0;&#xA0; song7.i<br>&#xA0;&#xA0;&#xA0; song8.i<br>&#xA0;&#xA0;&#xA0; drums.bat<br><br>Double click drums.bat. That will run NESASM3 and should produce the drums.nes file. Run that NES file in FCEUXD SP.<br><br>Use the controller to select songs and play them.&#xA0; Controls are as follows:<br>&#xA0;&#xA0; &#xA0;<br><b>Up</b>: Play<br><b>Down</b>: Stop <br><b>Right</b> : Next Song/SFX<br><b>Left</b> : Previous Song/SFX<br><br><b>Song0</b> is a silence song.&#xA0; Not selectable.<br><b>Song1-Song7</b> are the same as last week, but a few of them (1, 4 and 6) have drums now.<br><b style="color: rgb(255, 0, 0);">Song8</b>
is a new &quot;song&quot; that plays each of the Noise channel&apos;s 32 sounds, in
order from 00-1F.&#xA0; First it plays them with a sustained volume envelope
so that you can hear how they sound drawn out.&#xA0; Next they are played
using the 7-frame ve_drum_decay volume envelope we made so you can hear
how they sound as simple drum sounds.<br><br><b>Next Week</b>: More Complex Drums, Noise SFX
				