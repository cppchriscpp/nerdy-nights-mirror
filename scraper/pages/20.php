
					<b>Last Week</b>: <a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23452" target="_blank" original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23452">Sound Data, Pointer Tables and Headers</a><br><br><b>This Week</b>: Tempo, Note Lengths, Buffering and Rests<br><br><b><font size="4">Timing</font></b><br><br>Last
week we put together a huge chunk of the sound engine.&#xA0; We finally got
it to play something that resembled a song.&#xA0; But we had big limitations
when it came to timing and note lengths.&#xA0; We were using a single frame
counter to keep time across all 6 streams of the sound engine.&#xA0; This is
a problem because it imposes the music&apos;s speed on our sound effects.&#xA0;
If you were to use such a system in a real game, your sound effects
would speed up or slow down whenever you change to a faster or slower
song.<br><br>We also made the mistake of advancing the sound engine
when our frame counter hit its mark, but skipping it when it didn&apos;t.&#xA0;
What happens if a game event triggers a sound effect one or two frames
after the counter hits its mark?&#xA0; The sound effect won&apos;t start until
the next time our counter reaches its mark - we have to wait for it!&#xA0;
There will be a delay.&#xA0; Not good.<br><br>Worst of all, our frame
counter also doesn&apos;t allow for variable note lengths.&#xA0; Unless every
song you write is going to consist of only 32nd notes, this is a
problem.&#xA0; It becomes apparent then that we need a more complex timing
system.<br><br><font size="3"><b>Tempo</b></font><br>
<br>We&apos;ll correct the first two problems by ripping out the universal
counter and giving each stream it&apos;s own private counter.&#xA0; We&apos;ll also
change our method of counting.&#xA0; Our old method of counting frames and
taking action when we reach a certain number is very limited.&#xA0; For
example, let&apos;s say that we have a song and our frame counter is taking
action every 4 frames.&#xA0; Maybe the song sounds a tad faster than we
want, so we slow it down by changing the speed to update once every 5
frames.&#xA0; But now the song sounds too slow.&#xA0; The speed we really want is
somewhere in between 4 and 5, but we can&apos;t get there with our frame
counting method.&#xA0; Instead we&apos;ll use a ticker.<br><br><b>Ticker</b><br>The ticker method involves taking a number (a <b>tempo</b>)
and adding it to a total, frame by frame.&#xA0; Eventually, that total will
wraparound from FF-&gt;00 and when it does the carry flag will be set
(a <b>tick</b>).&#xA0; This carry flag tick will be the signal we look for to advance our stream.<br><br>For
example, let&apos;s say our tempo value is $40 and our total starts at $00.&#xA0;
After one frame we will add our tempo to the total.&#xA0; $00 + $40 = $40.&#xA0;
Now our total is $40.&#xA0; Another frame goes by (2).&#xA0; We add our tempo to
the total again.&#xA0; $40 + $40 = $80.&#xA0; Our total is $80.&#xA0; Another frame
goes by (3).&#xA0; $80 + $40 = $C0.&#xA0; Another frame goes by (4).&#xA0; $C0 + $40 =
$00.&#xA0; Carry flag is set.&#xA0; TICK!&#xA0; A tick tells us that it is time to
advance this stream.&#xA0; When we finish updating, we start adding again
until we get another tick.<br><br>As you can see, a tempo value of $40
will advance our stream once every 4 frames.&#xA0; If you do some math (256
/ 5), you will discover that a tempo of $33 will advance the stream
roughly every 5 frames.&#xA0; If $40 is too fast for your song and $33 is
too slow, you still have the values $34-$39 to experiment with.&#xA0; Much
more versatile!&#xA0; To see why this works, let&apos;s see what happens with a
tempo value of say $36:<br><br><span style="font-family: Courier New;">$00 + $36 + $36 + $36 + $36 + $36 = $0E (Tick in 5 frames)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$0E + $36 + $36 + $36 + $36 + $36 = $1C (Tick in 5 frames)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$1C + $36 + $36 + $36 + $36&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; = $02 (Tick in 4 frames)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$02 + $36 + $36 + $36 + $36 + $26 = $10 (Tick in 5 frames)</span><br><br>A
tempo of $36 produces a tick every 5 frames most of the time, but
sometimes it only takes 4 frames.&#xA0; You might think that this disparity
would make our song sound uneven, but really a single frame only lasts
about 1/60 of a second.&#xA0; Our ears won&apos;t notice.&#xA0; It will sound just
right to us.<br><br>Here is some code that demonstrates how to implement a ticker:<br><br><span style="font-family: Courier New;">stream_tempo .rs 6&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the value to add to our ticker total each frame</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream_ticker_total .rs 6&#xA0;&#xA0; ;our running ticker total.</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_play_frame:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_disable_flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .done&#xA0;&#xA0; ;if disable flag is set, don&apos;t advance a frame</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldx #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop: </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #$01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .endloop&#xA0;&#xA0;&#xA0; ;if stream disabled, skip this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;add the tempo to the ticker total.&#xA0; If there is a FF-&gt; 0 transition, there is a tick</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">lda stream_ticker_total, x</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; adc stream_tempo, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta stream_ticker_total, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bcc .endloop&#xA0;&#xA0;&#xA0; ;carry clear = no tick. if no tick, we are done with this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_fetch_byte&#xA0;&#xA0; ;else there is a tick, so do stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do more stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.endloop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inx</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpx #$06</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br><b>Initializing</b><br>Anytime we add a new feature to our sound engine we will want to ask ourselves the following questions:<br><br>1) Is this a feature that needs to be initialized for each song/sfx?<br>2) If so, are the values we use to initialize the feature variable (ie, not necessarily the same for every song/sfx)?<br><br>If the answer to question #1 is yes, we will have to update sound_load to initialize the feature.<br>If
the answer to question #2 is also yes, we will have to add a field to
the song header format.&#xA0; The values to plug into the initialization are
different for each song, so the songs&apos; headers will need to provide
those values for us.<br><br>In the case of our new timing scheme, we
have two variables that need to be initialized: sound_ticker_total and
sound_tempo.&#xA0; Of the two, only sound_tempo will be variable.&#xA0; Different
songs will have different tempos, but they won&apos;t need to have different
starting sound_ticker_totals.&#xA0; So we will have to add one new field to
our song header format for tempo:<br><br><span style="font-family: Courier New;">main header:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">byte #&#xA0; | what it tells us</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | number of streams</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">01+&#xA0;&#xA0;&#xA0;&#xA0; | stream headers (one for each stream)</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">stream headers:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">byte #&#xA0; | what it tells us</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">--------+----------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">00&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | which stream (stream number)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">01&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | status byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">02&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | which channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">03&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | initial volume (and duty for squares)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">04-05&#xA0;&#xA0; | pointer to data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New; background-color: rgb(255, 255, 255); color: rgb(255, 0, 0);">06&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; | initial tempo</span><br><br>Then
we will need to edit sound_load to read this new byte for each stream
and store it in RAM.&#xA0; We&apos;ll also want to initialize stream_ticker_total
to some fixed starting value, preferably a high one so that the first
tick will happen without a delay.&#xA0; Finally, we will have to update all
of our songs to include tempos in their headers.<br><br><font size="4"><b>Note Lengths</b></font><br><br>We
still have the problem of note lengths.&#xA0; Songs are made up of notes of
variable length: quarter notes, eighth notes, sixteenth notes, etc.&#xA0;
Our sound engine needs to be able to differentiate between different
note lengths.&#xA0; But how?&#xA0; We will use note length counters.<br><br><b>Note Length Counters</b><br>Think
of the fastest note you&apos;d ever need to play, say a 32nd note.&#xA0; Since
that will be our fastest note, we&apos;ll give it the smallest count
possible: $01.&#xA0; The next fastest note is a 16th note.&#xA0; In music, a 16th
note equals two 32nd notes.&#xA0; In other words, a 16th note lasts twice as
long as a 32nd note.&#xA0; So we will give it a count value that is twice
the count value of our 32nd note: $02.&#xA0; The next fastest note is an 8th
note.&#xA0; An 8th note equals two 16th notes.&#xA0; It is twice as long as a
16th note.&#xA0; So its count value will be twice that of the 16th note:
$04.&#xA0; Going all the way up to a whole note, we can produce a lookup
table like this:<br><br><span style="font-family: Courier New;">note_length_table:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0; ;32nd note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $02&#xA0;&#xA0; ;16th note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $04&#xA0;&#xA0; ;8th note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $08&#xA0;&#xA0; ;quarter note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $10&#xA0;&#xA0; ;half note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $20&#xA0;&#xA0; ;whole note</span><br>&#xA0;&#xA0; &#xA0;<br>We&apos;ll add more entries later for things like dotted quarter notes, but for now this is sufficient to get us started.<br><br>To play different note lengths, we will give each stream a note length counter:<br><br><span style="font-family: Courier New;">stream_note_length_counter .rs 6</span><br><br>When
a note is played, for example an 8th note, its count value will be
pulled from the note_length_table and stored in the stream&apos;s note
length counter.&#xA0; Then every time a tick occurs we will decrement the
counter.&#xA0; When the note length counter reaches 0, it will signal to us
that our note has finished playing and it is time for the next note.&#xA0;
To say it another way, a note&apos;s count value is simply how many ticks it
lasts.&#xA0; An eighth note is 4 ticks long.&#xA0; A quarter note is 8 ticks
long.&#xA0; A half note is 16 ticks long ($10).<br><br><b>Note Lengths in Data</b><br>Now
we need to add note lengths to our sound data.&#xA0; Recall that we
specified that byte values in the range of $80-$9F were note lengths:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note stuff</span><br>&#xA0;&#xA0; &#xA0;<br>So
the first byte value that we can use for note lengths is $80.&#xA0; We are
going to be reading from a lookup table (note_length_table above), so
we should assign the bytes in the same order as the lookup table. <br><br><span style="font-family: Courier New;">-----+--------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">byte | note length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">-----+--------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$80&#xA0; | 32nd note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$81&#xA0; | 16th note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$82&#xA0; | 8th note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$83&#xA0; | quarter note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$84&#xA0; | half note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">$85&#xA0; | whole note</span><br><br>Now we can use these values in our sound data to represent note lengths:<br><br><span style="font-family: Courier New;">;music data for song 0, square 1 channel</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">song0_sq1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $82, C3 ;play a C eighth note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte $84, D5 ;play a D half note</span><br>&#xA0;&#xA0; &#xA0;<br>Of
course, memorizing which byte value corresponds to which note length is
a pain.&#xA0; Let&apos;s create some aliases to make it easier on us when we are
creating our sound data:<br><br><span style="font-family: Courier New;">;note length constants</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">thirtysecond = $80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sixteenth = $81</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">eighth = $82</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">quarter = $83</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">half = $84</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">whole = $85</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">song0_sq1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, C3&#xA0;&#xA0;&#xA0; ;play a C eighth note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte half, D5&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;play a D half note</span><br>&#xA0;&#xA0; &#xA0;<br><b>Pulling from the table</b><br>There
is a small problem here.&#xA0; Lookup tables index from 0.&#xA0;&#xA0; This wasn&apos;t a
problem for note values (C5, D3, G6) because our note range started
from 0 ($00-$7f).&#xA0; But our note length data has a range of $80-$9F.&#xA0;
Somehow we will need to translate the note length byte that comes from
the data stream into a number we can use to index into our table.&#xA0; In
other words, we need to figure out a way to turn $80 into $00, $81 into
$01, $82 into $02, etc.&#xA0; Anything come to mind?<br><br>If you thought
&quot;just subtract $80 from the note length value&quot;, give yourself a
cookie.&#xA0; If you thought &quot;just chop off the 7-bit&quot;, give yourself two
cookies.&#xA0; Both solutions work, but the second solution is a little bit
faster and only takes one instruction to perform:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.fetch:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; and #%01111111&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;chop off bit7</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save Y because we are about to destroy it</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda note_length_table, y&#xA0;&#xA0;&#xA0; ;get the note length count value</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta stream_note_length_counter, x&#xA0;&#xA0; ;stick it in our note length counter</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;restore Y</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set index to next byte in the stream</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; jmp .fetch&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;fetch another byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note stuff</span><br>&#xA0;&#xA0; &#xA0;<br>Notice
that we jump back up to .fetch after we set the note length counter.&#xA0;
This is so that we can read the note that will surely follow the note
length in the data stream.&#xA0; If we simply stop after setting the note
length, we&apos;ll know how long to play, but we won&apos;t know which note to
play!<br><br>Here&apos;s an updated sound_play_frame routine that implements
both the ticker and the note length counters.&#xA0; Notice how the note
length counter is only decremented when we have a tick, and we only
advance the stream when the note length counter reaches zero:<br><br><span style="font-family: Courier New;">sound_play_frame:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_disable_flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .done&#xA0;&#xA0; ;if disable flag is set, don&apos;t advance a frame</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldx #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop: </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #$01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .endloop&#xA0;&#xA0;&#xA0; ;if stream disabled, skip this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;add the tempo to the ticker total.&#xA0; If there is a FF-&gt; 0 transition, there is a tick</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ticker_total, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_tempo, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ticker_total, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .endloop&#xA0;&#xA0;&#xA0; ;carry clear = no tick.&#xA0; if no tick, we are done with this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">dec stream_note_length_counter, x&#xA0;&#xA0; ;else there is a tick. decrement the note length counter</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .endloop&#xA0;&#xA0;&#xA0; ;if counter is non-zero, our note isn&apos;t finished playing yet</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_fetch_byte&#xA0;&#xA0; ;else our note is finished.&#xA0; Time to read from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do more stuff. set volume, note, sweep, etc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.endloop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inx</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpx #$06</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br><br>We
have one last change to make.&#xA0; When we load a new song we will want it
to start playing immediately, so we should initialize the
stream_note_length_counter in the sound_load routine to do just that.&#xA0;
Our sound_play_frame routine decrements the counter and takes action if
the result is zero.&#xA0; Therefore, to ensure that our song starts
immediately, we should initialize our stream_note_length_counter to $01:<br>&#xA0;&#xA0; &#xA0;<br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;somewhere inside the loop of sound_load</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_length_counter, x</span><br>&#xA0;&#xA0; &#xA0;<br>And
now our engine supports note lengths.&#xA0; But there is still room for
improvement.&#xA0; What if we want to play a series of 8th notes?&#xA0; Not an
uncommon thing to have in music.&#xA0; Here is how our data would have to
look now:<br><br><span style="font-family: Courier New;">sound_data:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, C5, eighth, E5, eighth, G5, eighth, C6, eighth, E6, eighth, G6, eighth, C7 ;Cmajor</span><br>&#xA0;&#xA0; &#xA0;<br>That&apos;s
a lot of &quot;eighth&quot; bytes.&#xA0; Wouldn&apos;t it be better to just state &quot;eighth&quot;
once, and assume that all notes following it are eighth notes?&#xA0; Like
this:<br><br><span style="font-family: Courier New;">sound_data:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, C5, E5, G5, C6, E6, G6, C7 ;Cmajor</span><br>&#xA0;&#xA0; &#xA0;<br>That
saved us 6 bytes of ROM space.&#xA0; And if you consider that a game may
have 20+ songs, each with 4 streams of data, each with potentially
several strings of equal-length notes, this kind of change might save
us hundreds, maybe even thousands of bytes!&#xA0; Let&apos;s do it.<br><br>To
pull this off, we will have to store the current note length count
value in RAM.&#xA0; Then when our note length counter runs to 0, we will
refill it with our RAM count value.<br><br><span style="font-family: Courier New; color: rgb(255, 0, 0);">stream_note_length .rs 6&#xA0;&#xA0;&#xA0; ;note length count value</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">;-------</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.fetch:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%01111111&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;chop off bit7</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save Y because we are about to destroy it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_length_table, y&#xA0;&#xA0;&#xA0; ;get the note length count value</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">sta stream_note_length, x&#xA0;&#xA0; ;save the note length in RAM so we can use it to refill the counter</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_length_counter, x&#xA0;&#xA0; ;stick it in our note length counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;restore Y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set index to next byte in the stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jmp .fetch&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;fetch another byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do note stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;--------</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_play_frame:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_disable_flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .done&#xA0;&#xA0; ;if disable flag is set, don&apos;t advance a frame</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldx #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop: </span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #$01</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .endloop&#xA0;&#xA0;&#xA0; ;if stream disabled, skip this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;add the tempo to the ticker total.&#xA0; If there is a FF-&gt; 0 transition, there is a tick</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ticker_total, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_tempo, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ticker_total, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .endloop&#xA0;&#xA0;&#xA0; ;carry clear = no tick.&#xA0; if no tick, we are done with this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dec stream_note_length_counter, x&#xA0;&#xA0; ;else there is a tick. decrement the note length counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .endloop&#xA0;&#xA0;&#xA0; ;if counter is non-zero, our note isn&apos;t finished playing yet</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">lda stream_note_length, x&#xA0;&#xA0; ;else our note is finished. reload the note length counter</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta stream_note_length_counter, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_fetch_byte&#xA0;&#xA0; ;Time to read from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do more stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.endloop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inx</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpx #$06</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Adding
those 4 lines of code just saved us hundreds of bytes of ROM space.&#xA0; A
nice tradeoff for 6 bytes of RAM.&#xA0; Now our data will be made up of
&quot;strings&quot;, where we have a note length followed by a series of notes:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_data:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth, C5, E5, G5, C6, E6, G6, quarter, C6 ;six 8th notes and a quarter note</span><br>&#xA0;&#xA0; &#xA0;<br>Easy to read and easy to write.<br><b><br>
Other Note Lengths</b><br>Now that everything is setup, we can add more
note lengths to our note_length_table.&#xA0; Dotted notes are very common in
music.&#xA0; Dotted notes are equal in length to the note plus the next
fastest note.&#xA0; For example, a dotted quarter note = a quarter note + an
8th note.&#xA0; A dotted 8th note = an 8th note + a 16th note.&#xA0; Let&apos;s add
some dotted notes to our table:<br><br>note_length_table:<br>&#xA0;&#xA0;&#xA0; .byte $01&#xA0;&#xA0; ;32nd note<br>&#xA0;&#xA0;&#xA0; .byte $02&#xA0;&#xA0; ;16th note<br>&#xA0;&#xA0;&#xA0; .byte $04&#xA0;&#xA0; ;8th note<br>&#xA0;&#xA0;&#xA0; .byte $08&#xA0;&#xA0; ;quarter note<br>&#xA0;&#xA0;&#xA0; .byte $10&#xA0;&#xA0; ;half note<br>&#xA0;&#xA0;&#xA0; .byte $20&#xA0;&#xA0; ;whole note<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;---dotted notes<br>&#xA0;&#xA0;&#xA0; .byte $03&#xA0;&#xA0; ;dotted 16th note<br>&#xA0;&#xA0;&#xA0; .byte $06&#xA0;&#xA0; ;dotted 8th note<br>&#xA0;&#xA0;&#xA0; .byte $0C&#xA0;&#xA0; ;dotted quarter note<br>&#xA0;&#xA0;&#xA0; .byte $18&#xA0;&#xA0; ;dotted half note<br>&#xA0;&#xA0;&#xA0; .byte $30&#xA0;&#xA0; ;dotted whole note?<br>&#xA0;&#xA0; &#xA0;<br>The
actual order of our note_length_table doesn&apos;t matter.&#xA0; We just have to
make sure our aliases are in the same order as the table:<br><br><span style="font-family: Courier New;">;note length constants (aliases)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">thirtysecond = $80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sixteenth = $81</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">eighth = $82</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">quarter = $83</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">half = $84</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">whole = $85</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">d_sixteenth = $86</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">d_eighth = $87</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">d_quarter = $88</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">d_half = $89</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">d_whole = $8A&#xA0;&#xA0; ;don&apos;t forget we are counting in hex</span><br><br>Your
music will determine what other entries you&apos;ll need to add to your note
length table.&#xA0; If one of your songs has a really really long note, like
3 whole notes tied together, add it to the table ($60) and make an
alias for it (whole_x3).&#xA0; If your song contains a note that is seven
8th notes long (a half note plus a dotted quarter note tied together),
add it to the table ($1C) and make an alias for it (seven_eighths).<br><font size="4"><b><br>
Buffering APU Writes</b></font><br>Before, we&apos;ve been writing to the
APU one stream at a time.&#xA0; If two different streams shared a channel,
they would both write to the same APU ports.&#xA0; If three streams were to
share a channel, which is possible if there are two different sound
effects loaded into SFX_1 and SFX_2, all three would write to the same
APU ports in the same frame.&#xA0; This is bad practice.&#xA0; It can also cause
some unwanted noise on the square channels.<br><br>A better method is
to buffer our writes.&#xA0; Instead of writing to the APU ports directly,
each stream will instead write its data to temporary ports in RAM.&#xA0;
We&apos;ll keep our loop order, so sfx streams will still overwrite the
music streams.&#xA0; Then when all the streams are done, we will copy the
contents of our temporary RAM ports directly to the APU ports all at
once.&#xA0; This ensures that the APU ports only get written to once per
frame max.&#xA0; To do this, we first need to reserve some RAM space for our
temporary port variables:<br><br><span style="font-family: Courier New;">soft_apu_ports .rs 16</span><br><br>We reserved 16 bytes for our temporary ports.&#xA0; Each one corresponds to an APU port:<br><br><span style="font-family: Courier New;">soft_apu_ports+0&#xA0; -&gt; $4000&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;Square 1 ports</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+1&#xA0; -&gt; $4001</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+2&#xA0; -&gt; $4002</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+3&#xA0; -&gt; $4003</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+4&#xA0; -&gt; $4004&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;Square 2 ports</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+5&#xA0; -&gt; $4005</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+6&#xA0; -&gt; $4006</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+7&#xA0; -&gt; $4007</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+8&#xA0; -&gt; $4008&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;Triangle ports</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+9&#xA0; -&gt; $4009 (unused)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+10 -&gt; $400A</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+11 -&gt; $400B</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+12 -&gt; $400C&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;Noise ports</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+13 -&gt; $400D (unused)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+14 -&gt; $400E</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">soft_apu_ports+15 -&gt; $400F</span><br><br>Let&apos;s
implement this by working backwards.&#xA0; First we will edit
sound_play_frame and pull our call to se_set_apu out of the loop.&#xA0; We
do this because we only want to write to the APU once, after all the
streams are done looping:<br><br><span style="font-family: Courier New;">;--------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">; sound_play_frame advances the sound engine by one frame</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_play_frame:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda sound_disable_flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .done&#xA0;&#xA0; ;if disable flag is set, don&apos;t advance a frame</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldx #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #$01&#xA0;&#xA0;&#xA0; ;check whether the stream is active</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .endloop&#xA0; ;if the channel isn&apos;t active, skip it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;add the tempo to the ticker total.&#xA0; If there is a FF-&gt; 0 transition, there is a tick</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ticker_total, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_tempo, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ticker_total, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .endloop&#xA0;&#xA0;&#xA0; ;carry clear = no tick.&#xA0; if no tick, we are done with this stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dec stream_note_length_counter, x&#xA0;&#xA0; ;else there is a tick. decrement the note length counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .endloop&#xA0;&#xA0;&#xA0; ;if counter is non-zero, our note isn&apos;t finished playing yet</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_length, x&#xA0;&#xA0; ;else our note is finished. reload the note length counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_length_counter, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; jsr se_fetch_byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">;snip</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.endloop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inx</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpx #$06</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">jsr se_set_apu</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Next we will modify se_set_apu to copy the temporary APU ports to the real APU ports:<br><br><span style="font-family: Courier New;">se_set_apu:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$0F</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpy #$09</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .skip&#xA0;&#xA0; ;$4009 is unused</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cpy #$0D</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .skip&#xA0;&#xA0; ;$400D is unused</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4000, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.skip:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dey</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .loop&#xA0;&#xA0; ;stop the loop when Y is goes from $00 -&gt; $FF</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Now
we have to write the subroutine that will populate the temporary APU
ports with a stream&apos;s data.&#xA0; This part will get more complicated as we
add more features to our sound engine, but for now it&apos;s quite simple:<br><br><span style="font-family: Courier New;">se_set_temp_ports:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_vol_duty, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports, y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;vol</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$08</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+1, y&#xA0;&#xA0;&#xA0;&#xA0; ;sweep</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+2, y&#xA0;&#xA0;&#xA0;&#xA0; ;period LO</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+3, y&#xA0;&#xA0;&#xA0;&#xA0; ;period HI</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>We
will make the call to se_set_temp_ports after our call to
se_fetch_byte, where the old se_set_apu call was before we snipped it
out of the loop.&#xA0; Notice that we don&apos;t bother to check the channel
before writing the sweep.&#xA0; se_set_apu takes care of this part for us.&#xA0;
There&apos;s no harm in writing these values to RAM, so we&apos;ll avoid
branching here to simplify the code.<br><br><b>Crackling Sounds</b><br>Writing
to the 4th port of the Square channels ($4003/$4007) has the side
effect of resetting the sequencer.&#xA0; If we write here too often, we will
get a nasty crackling sound out of our Squares.&#xA0; This is not good.<br><br>The
way our engine is setup now, we call se_set_apu once per frame.&#xA0;
se_set_apu writes to $4003/$4007, so these ports will get written to
once per frame.&#xA0; This is too often.&#xA0; We need to find a way to write
here less often.&#xA0; We will do this by cutting out redundant writes.&#xA0; If
the value we want to write this frame is the same as the value written
last frame, skip the write.<br><br>First we will need to keep track of what was last written to the ports.&#xA0; This will require some new variables:<br><br><span style="font-family: Courier New;">sound_sq1_old .rs 1&#xA0; ;the last value written to $4003</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_sq2_old .rs 1&#xA0; ;the last value written to $4007</span><br><br>Whenever
we write to one of these ports, we will also write the value to the
corresponding sound_port4_old variable.&#xA0; Saving this value will allow
us to compare against it next frame.&#xA0; To implement this, we will have
to unroll our loop in se_set_apu:<br><br><span style="font-family: Courier New;">se_set_apu:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4000</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4001</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4002</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4003</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_sq1_old&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save the value we just wrote to $4003</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.square2:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4004</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+5</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4005</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4006</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+7</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4007</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_sq2_old&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save the value we just wrote to $4007</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.triangle:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+8</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4008</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+10</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400A</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+11</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400B</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.noise:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+12</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400C</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+14</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400E</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+15</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400F</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Now
we have a variable that will keep track of the last value written to a
channel&apos;s 4th port.&#xA0; The next step is to add a check before we write:<br><br><span style="font-family: Courier New;">se_set_apu:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4000</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4001</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4002</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">cmp sound_sq1_old&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;compare to last write</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; beq .square2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;don&apos;t write this frame if they were equal</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4003</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_sq1_old&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save the value we just wrote to $4003</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.square2:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4004</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+5</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4005</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4006</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+7</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">cmp sound_sq2_old</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; beq .triangle</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4007</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_sq2_old&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save the value we just wrote to $4007</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.triangle:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+8</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4008</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+10&#xA0;&#xA0; ;there is no $4009, so we skip it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400A</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+11</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400B</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.noise:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+12</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400C</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+14&#xA0;&#xA0; ;there is no $400D, so we skip it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400E</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda soft_apu_ports+15</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $400F</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Finally
we have to consider initialization.&#xA0; The only case we really have to
worry about is the first time a song is played in the game.&#xA0; Consider
what happens if we initialize the sound_sq1_old and sound_sq2_old
variables to $00.&#xA0; We are essentially saying that on startup (RESET)
the last byte written to $4003/$4007 was a $00, which isn&apos;t true of
course.&#xA0; On startup, no write has ever been made to these ports.&#xA0; If we
initialize to $00, and if the first note of the first song played has a
$00 for the high 3 bits of its period, it will get skipped.&#xA0; That is
not what we want.&#xA0; Instead, we should initialize these variables to
some value that will never be written to $4003/$4007, like $FF.&#xA0; This
ensures that the first note(s) played in the game won&apos;t be skipped.<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_init:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$0F</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta $4015&#xA0;&#xA0; ;enable Square 1, Square 2, Triangle and Noise channels</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_disable_flag&#xA0; ;clear disable flag</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;later, if we have other variables we want to initialize, we will do that here.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">lda #$FF</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta sound_sq1_old</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta sound_sq2_old</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_silence:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$30</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">sta soft_apu_ports&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set Square 1 volume to 0</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+4&#xA0;&#xA0;&#xA0; ;set Square 2 volume to 0</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+12&#xA0;&#xA0; ;set Noise volume to 0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$80</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">sta soft_apu_ports+8&#xA0;&#xA0;&#xA0;&#xA0; ;silence Triangle</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br><font size="4"><b>Rests</b></font><br><br>The final topic we will cover this lesson is rests.&#xA0; A <b>rest</b>
is a period of silence in between notes.&#xA0; Like notes, rests can be of
variable length: quarter rest, half rest, whole rest, etc.&#xA0; In other
words a rest is a silent note.<br><br>So how will we implement it?&#xA0; We
will handle rests by considering a rest to be special case note.&#xA0; We
will give the rest a dummy period in our note table.&#xA0; Then, when we
fetch a byte from the data stream and determine the byte to be a note,
we will add an extra check to see if that note is a rest.&#xA0; If it is, we
will make sure that it shuts up the stream.<br><br>First let&apos;s add the
rest to our note table.&#xA0; We will give it a dummy period.&#xA0; It doesn&apos;t
really matter what value we use.&#xA0; I&apos;m going to give it a period of
$0000.&#xA0; We will also want to add the rest to our list of note aliases:<br><br><span style="font-family: Courier New;">note_table:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word $07F1, $0780, etc...</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;....more note table values here</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.word $0000 ;rest.&#xA0; Last entry</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;Note: octaves in music traditionally start at C, not A&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">A1 = $00&#xA0;&#xA0;&#xA0; ;the &quot;1&quot; means Octave 1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">As1 = $01&#xA0;&#xA0; ;the &quot;s&quot; means &quot;sharp&quot;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">Bb1 = $01&#xA0;&#xA0; ;the &quot;b&quot; means &quot;flat&quot;&#xA0; A# == Bb, so same value</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">B1 = $02</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;..... other aliases here</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">F9 = $5c</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">Fs9 = $5d</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">Gb9 = $5d</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">rest = $5e</span><br><br>Now
we can use the symbol &quot;rest&quot; in our music data.&#xA0; &quot;rest&quot; will evaluate
to the value $5E, which falls within our note range ($00-$7F).&#xA0; When
our sound engine encounters a $5E in the data stream, it will pull the
period ($0000) from the note table and store it in RAM.&#xA0; A period of
$0000 is actually low enough to silence the square channels, but the
triangle channel is still audible at this period so we have more work
to do.<br><br><b>Checking for a rest</b><br>When we encounter a rest,
we will want to tell the sound engine to shut this stream up until the
next note.&#xA0; The rest functions differently from all the other notes, so
we will need to make a special check for it in our code.&#xA0; We will make
a subroutine se_check_rest to do this for us:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.fetch:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bpl .note&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if &lt; #$80, it&apos;s a Note</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .note_length&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else if &lt; #$A0, it&apos;s a Note Length</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.opcode:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else it&apos;s an opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Opcode stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note_length:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note Length stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;save our index into the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table+1, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;restore data stream index</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">;check if it&apos;s a rest</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; jsr se_check_rest&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.update_pointer:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tya</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bcc .end</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; inc stream_ptr_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.end:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>se_check_rest
will check to see if the note value is equal to $5E or not.&#xA0; If it is,
we will need to tell the sound engine to silence the stream.&#xA0; If the
note isn&apos;t equal to $5E, we can go on our merry way.<br><br>How will we
silence our stream then?&#xA0; This is actually a little complicated.&#xA0;
Recall that the stream&apos;s volume (stream_vol_duty) is set in the song&apos;s
header.&#xA0;&#xA0; se_set_temp_ports copies the value of stream_vol_duty to
soft_apu_ports.&#xA0; If we have se_check_rest modify the stream_vol_duty
variable directly (set it to 0 volume), the old volume value
disappears.&#xA0; We won&apos;t know what to restore it to when we are done with
our rest.&#xA0; Oh no!<br><br>What we will want to do instead is leave
stream_vol_duty alone.&#xA0; We will copy it into soft_apu_ports every frame
as usual.&#xA0; Then, after the copy we will check to see if we are
currently resting.&#xA0; If we are, we will make another write
soft_apu_ports with a value that will set the volume to 0.&#xA0; Make sense?<br><br><b>stream_status</b><br>To
do this we will need to keep track of our resting status in a
variable.&#xA0; If our sound engine encounters a $5E in the data stream,
we&apos;ll turn our resting status on.&#xA0; If it&apos;s not, we&apos;ll turn our resting
status off.&#xA0; There are only two possibilities: on or off.&#xA0; Rather than
declare a whole new block of variables and waste six bytes of RAM,
let&apos;s assign one of the bits in our stream_status variable to be our
rest indicator:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">Stream Status Byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">76543210</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ||</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; |+- Enabled (0: stream disabled; 1: enabled)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; +-- Rest (0: not resting; 1: resting)</span><br>&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;<br>Our new subroutine se_check_rest will be in charge of setting or clearing this bit of the status byte:<br><br><span style="font-family: Courier New;">se_check_rest:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0; ;read the note byte again</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; cmp #rest&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;is it a rest? (==$5E)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .not_rest</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ora #%00000010&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if so, set the rest bit in the status byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; bne .store&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this will always branch.&#xA0; bne is cheaper than a jmp.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.not_rest:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; and #%11111101&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;clear the rest bit in the status byte</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.store:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_status, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Then we modify se_set_temp_ports to check the rest bit and silence the stream if it is set:<br><br><span style="font-family: Courier New;">se_set_temp_ports:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_vol_duty, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports, y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;vol</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$08</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+1, y&#xA0;&#xA0;&#xA0;&#xA0; ;sweep</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+2, y&#xA0;&#xA0;&#xA0;&#xA0; ;period LO</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta soft_apu_ports+3, y&#xA0;&#xA0;&#xA0;&#xA0; ;period HI</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">;check the rest flag. if set, overwrite volume with silence value </span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda stream_status, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; and #%00000010</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; beq .done&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;if clear, no rest, so quit</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda stream_channel, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; cmp #TRIANGLE&#xA0;&#xA0; ;if triangle, silence with #$80</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; beq .tri&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda #$30&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;else, silence with #$30</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; bne .store&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;this will always branch.&#xA0; bne is cheaper than a jmp.</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">.tri:</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; lda #$80</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">.store:&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; sta soft_apu_ports, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.done:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>That&apos;s it.&#xA0; Now our engine supports rests!&#xA0; They work just like notes, so their lengths are controlled with note lengths:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">song_data:&#xA0; ;this data has two quarter rests in it.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte half, C2, quarter, rest, eighth, D4, C4, quarter, B3, rest</span><br>&#xA0;&#xA0; &#xA0;<br><b>Putting It All Together</b><br>Download and unzip the <a href="downloads/NerdyNightsSoundSourceCollection/tempo.zip" target="_blank" original-href="http://tummaigames.com/tempo.zip">tempo.zip</a> sample files.&#xA0; Make sure the following files are in the same folder as NESASM3:<br><br>&#xA0;&#xA0;&#xA0; tempo.asm<br>&#xA0;&#xA0;&#xA0; sound_engine.asm<br>&#xA0;&#xA0;&#xA0; tempo.chr<br>&#xA0;&#xA0;&#xA0; note_table.i<br>&#xA0;&#xA0;&#xA0; note_length_table.i<br>&#xA0;&#xA0;&#xA0; song0.i<br>&#xA0;&#xA0;&#xA0; song1.i<br>&#xA0;&#xA0;&#xA0; song2.i<br>&#xA0;&#xA0;&#xA0; song3.i<br>&#xA0;&#xA0;&#xA0; song4.i<br>&#xA0;&#xA0;&#xA0; song5.i<br>&#xA0;&#xA0;&#xA0; tempo.bat<br><br>Double click tempo.bat. That will run NESASM3 and should produce the tempo.nes file. Run that NES file in FCEUXD SP.<br><br>Use the controller to select songs and play them.&#xA0; Controls are as follows:<br>&#xA0;&#xA0; &#xA0;<br><b>Up</b>: Play<br><b>Down</b>: Stop <br><b>Right</b>: Next Song/SFX<br><b>Left</b>: Previous Song/SFX<br><br>Song0
is a silence song.&#xA0; Not selectable.&#xA0; tempo.asm &quot;plays&quot; song0 to stop
the music when you press down.&#xA0; See song0.i to find out how it works.<br>Song1 is last week&apos;s evil sounding series of minor thirds, but much faster now thanks to tempo settings.<br>Song2 is the same short sound effect from last week.<br>Song3
is a simple descending chord progression.&#xA0; We saved some bytes in the
triangle data using note lengths (compare to last week&apos;s file)<br>Song4 is a new song that showcases variable note lengths and rests.<br>Song5
is a short sound effect.&#xA0; It plays 10 notes extremely fast.&#xA0; Play it
over songs and see how it steals the SQ2 channel from the music.<br><br>Try
creating your own songs and sound effects and add them into the mix.&#xA0;
To add a new song you will need to take the following steps:<br><br>1)
create a song header and song data (use the included songs as
reference).&#xA0; Don&apos;t forget to add tempos for each stream in your
header.&#xA0; Data streams are terminated with $FF.<br>2) add your header to the song_headers pointer table at the bottom of sound_engine.asm<br>3) update the constant NUM_SONGS to reflect the new song number total (also at the bottom of sound_engine.asm)<br><br>Although
not necessary, I recommend keeping your song data in a separate file
like I&apos;ve done with song0.i, song1.i, song2.i and song3.i.&#xA0; This makes
it easier to find the data if you need to edit your song later.&#xA0; If you
do this, don&apos;t forget to .include your file.<br><br><b>Next Week</b>: <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253">Volume Envelopes</a><br>
				