
					<b>Last Week</b>: <a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25583" target="_blank">Opcodes and Looping</a><br><br><b>This Week</b>: More opcodes: Finite Loops, Key Changes, Chord Progressions<br><br><font size="4"><b>Opcodes</b></font><br>Last
week we learned how to use opcodes.&#xA0; Opcodes allow a song&apos;s streams to
call a subroutine mid-play.&#xA0; This is a very powerful tool.&#xA0; We learned
some of the most common opcodes: infinite loop (really a jump), change
volume envelopes and change duty cycles.&#xA0; Today we are going to expand
on opcodes and learn some cool opcode tricks that can save us a lot (!)
of bytes and time.<br><b><font size="3"><br>
Finite Looping</font></b><br>Last week we added the infinite loop
opcode, which was really just an unconditional jump back to an earlier
part of the song.&#xA0; Today we&apos;re going to add a finite loop opcode.&#xA0; A
finite loop opcode tells the sound engine to repeat a particular
section of a song X times, where X is some number defined by you.&#xA0; In
the Battle Kid theme song I added last week there is a passage that
looks like this:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte sixteenth</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, E4, E3, E2</span><br>&#xA0;&#xA0; &#xA0;<br>This
is really just the same 4 notes repeated over and over again.&#xA0; Wouldn&apos;t
it be cooler if we could do something like this instead:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte sixteenth</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop_13_times_please</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, E4, E3, E2</span><br>&#xA0;&#xA0; &#xA0;<br>That
saves a lot of bytes.&#xA0; We go from 56 bytes all the way down to around
10.&#xA0; The Battle Kid song actually plays this same phrase on both square
channels, so really we go from 100+ bytes down to 20 or so.&#xA0; That&apos;s a
big deal!&#xA0; If we consider how common repetitions of 4 or 8 occur in
music, we can easily see that having a finite loop opcode could
potential save us hundreds if not thousands of bytes in our sound data.<br><br><b>Finite Looping?</b><br>So
what is a finite loop really?&#xA0; We saw that with an infinite loop it was
really more like an unconditional jump.&#xA0; When the sound engine hits the
infinite loop opcode, it jumps back, always, no matter what, no
questions asked.&#xA0;&#xA0; A finite loop on the other hand is a conditional
jump.&#xA0; It checks a counter.&#xA0; If the counter isn&apos;t 0 it jumps.&#xA0; If it is
0, it doesn&apos;t jump. &#xA0;<br><b><br>
Loop Counter</b><br>First things first we need a loop counter.&#xA0; Each
stream will have the ability to loop, so each stream will need its own
loop counter:<br><br><span style="font-family: Courier New;">stream_loop1 .rs 6&#xA0; ;loop counter variable (one for each stream)</span><br><br>We will want to initialize this to 0 in our sound_load code:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_loop1, x</span><br style="font-family: Courier New;"><br>Next
we will need a way to set this counter to some value.&#xA0; Some games
bundle this up together in the finite loop opcode, but I prefer to make
it its own opcode:<br><br><span style="font-family: Courier New;">;-----------------------------------------------------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;this is our JUMP TABLE!</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_infinite_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_duty&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.word se_op_set_loop1_counter&#xA0;&#xA0; ;$A4</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;etc, one entry per subroutine</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;these are aliases to use in the sound data.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">endsound = $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop = $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">volume_envelope = $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">duty = $A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">set_loop1_counter = $A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_set_loop1_counter:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read the argument (# times to loop)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_loop1, x&#xA0;&#xA0;&#xA0;&#xA0; ;store it in the loop counter variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br><br>Now we have an easy way to set the loop counter any time we want, like this:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;somewhere in sound data:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_loop1_counter, $04&#xA0;&#xA0;&#xA0; ;repeat 4 times</span><br><b><br>
Looping With The Counter</b><br>Our finite loop opcode will work like the infinite loop opcode, with two changes:<br><br>1) it will decrement the loop counter<br>2) it will check the result and only jump on a non-zero result<br><br>Let&apos;s write it:<br><br><span style="font-family: Courier New;">;-----------------------------------------------------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;this is our JUMP TABLE!</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_infinite_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_duty&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_set_loop1_counter&#xA0;&#xA0; ;$A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.word se_op_loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A5</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;etc, one entry per subroutine</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;these are aliases to use in the sound data.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">endsound = $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop = $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">volume_envelope = $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">duty = $A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">set_loop1_counter = $A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">loop1 = $A5</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_loop1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dec stream_loop1, x&#xA0;&#xA0;&#xA0;&#xA0; ;decrement the counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_loop1, x&#xA0;&#xA0;&#xA0;&#xA0; ;and check it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .last_iteration&#xA0;&#xA0;&#xA0;&#xA0; ;if zero, we are done looping</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop_back:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read ptr LO from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x&#xA0;&#xA0;&#xA0; ;update our data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read ptr HI from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_HI, x&#xA0;&#xA0;&#xA0; ;update our data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;update the pointer to reflect the new position.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;after opcodes return, we do an iny.&#xA0; Since we reset &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the stream buffer position, we will want y to start out at 0 again.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.last_iteration:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;skip the first byte of the address argument</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; the second byte will be skipped automatically upon return</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; (see se_fetch_byte.&#xA0; There is an &quot;iny&quot; after &quot;jsr se_opcode_launcher&quot;)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Now we can loop.&#xA0; To use the Battle Kid example above, we go from this (56 bytes):<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4, A3, E4, E3, E2</span><br>&#xA0;&#xA0; &#xA0;<br>to this (13 bytes):<br>&#xA0;&#xA0; &#xA0;<br>&#xA0;&#xA0;&#xA0; <span style="font-family: Courier New;">.byte set_loop1_counter, 13 ;repeat 13 times.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.intro_loop:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;make sure our loop point is AFTER we set the counter!</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, C4, E4, A4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the phrase to repeat.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;finite loop opcode</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word .intro_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;address to jump back to</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, E4, E3, E2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the last 4 notes</span><br>&#xA0;&#xA0; &#xA0;<br>Pretty nice savings.&#xA0; Chances are we will be using this opcode set a lot.<br><br><b>Bonus</b><br>We
can save a few more bytes here.&#xA0; You may have noticed that the code in
the .loop_back section of our finite loop opcode is identical to the
infinite loop code:<br><br><span style="font-family: Courier New;">se_op_loop1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip---</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop_back:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read ptr LO from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x&#xA0;&#xA0;&#xA0; ;update our data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read ptr HI from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_HI, x&#xA0;&#xA0;&#xA0; ;update our data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;update the pointer to reflect the new position.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;after opcodes return, we do an iny.&#xA0; Since we reset &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the stream buffer position, we will want y to start out at 0 again.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip---</span><br>&#xA0;&#xA0; &#xA0;<br>Compare with:<br><br><span style="font-family: Courier New;">se_op_infinite_loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read ptr LO from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_LO, x&#xA0;&#xA0;&#xA0; ;update our data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read ptr HI from the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_ptr_HI, x&#xA0;&#xA0;&#xA0; ;update our data stream position</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr+1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;update the pointer to reflect the new position.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_ptr_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta sound_ptr</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy #$FF&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;after opcodes return, we do an iny.&#xA0; Since we reset &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the stream buffer position, we will want y to start out at 0 again.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Why
have identical code in two places?&#xA0; Let&apos;s cut out the whole .loop_back
section and replace it with a &quot;jmp se_op_infinite_loop&quot;:<br><br><span style="font-family: Courier New;">se_op_loop1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dec stream_loop1, x&#xA0;&#xA0;&#xA0;&#xA0; ;decrement the counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_loop1, x&#xA0;&#xA0;&#xA0;&#xA0; ;check the counter</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; beq .last_iteration&#xA0;&#xA0;&#xA0;&#xA0; ;if zero, we are done looping</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">jmp se_op_infinite_loop ;if not zero, loop back</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.last_iteration:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;skip the first byte of the address argument</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; the second byte will be skipped automatically upon return</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ; (see se_fetch_byte after &quot;jsr se_opcode_launcher&quot;)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br><b>Multiple Finite Loops</b><br>You
may have been wondering why I named the finite loop opcode &quot;loop1&quot;.&#xA0;
Why stick a 1 on the end there?&#xA0; This is because sometimes one finite
loop opcode isn&apos;t enough.&#xA0; Consider the following song structure.&#xA0;
Assume each letter represents a long series of notes:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; A A A B C</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; A A A B C</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; A A A B C</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; A A A B C</span><br>&#xA0;&#xA0; &#xA0;<br>With one finite loop opcode you could reduce it to this:<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; (A A A B C)x4</span><br>&#xA0;&#xA0; &#xA0;<br>But if you had two finite loop opcodes available, you could nest them to reduce it even further:<br><br>&#xA0;&#xA0;<span style="font-family: Courier New;">&#xA0; (Ax3 B C)x4</span><br>&#xA0;&#xA0; &#xA0;<br>If
the music you write has a lot of patterns like this, it may be worth
your while to have two or more finite loop opcodes available to you so
that you can nest them.&#xA0; To add another finite loop opcode you need to:<br><br>1) declare another loop counter variable block in RAM (stream_loop2 .rs 6)<br>2) initialize the new loop counter to 0 in the sound_load routine.<br>3) add a new opcode for setting the new loop counter (se_op_set_loop2_counter)<br>4) add a new opcode to check the new counter and loop (se_op_loop2)<br>5) make sure to add the new opcodes to the jump table and give them an alias (set_loop2_counter, loop2).<br><br><br>Each
finite loop opcode you add requires 6 bytes of RAM (a limited
resource!), so please consider carefully if it is worth the tradeoff.&#xA0;
It all depends on your music data.<br><br>
<br><b><font size="3">Changing Keys</font></b><br><br>Another useful
feature to have is the ability to change keys.&#xA0; Imagine you write a
song and you have it all done.&#xA0; Then at the last minute you decide you
want it to be in another key, say a step (2 notes) lower.&#xA0; Rather than
rewrite the whole song by hand (it takes forever), wouldn&apos;t it be nice
if there was an opcode that you could set to automatically subtract two
from every note?&#xA0; What if you have a song pattern that gets played in
more than one key (a rhythm track for a Blues song, for example)?&#xA0; We
could save lots of bytes if we can figure out a way to write the
pattern once, and then loop it while changing keys each iteration.&#xA0;
Let&apos;s do it.<br><br><b>Note Offset</b><br>We will implement keys by having a note offset variable:<br><br><span style="font-family: Courier New;">stream_note_offset .rs 6&#xA0;&#xA0;&#xA0; ;note offset</span><br><br>The
note offset is a value that gets added to the note value before pulling
the period out of the note_table.&#xA0; We will initialize
stream_note_offset to 0 so that the default behavior is to add 0 to the
note (resulting in no change).&#xA0; However, if we set stream_note_offset
to some value via an opcode, it will change the notes.&#xA0; Here is an
updated se_fetch_byte that demonstrates how this works:<br><br><span style="font-family: Courier New;">se_fetch_byte:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;...snip...</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.note:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;do Note stuff</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;save our index into the data stream</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">clc</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; adc stream_note_offset, x&#xA0;&#xA0; ;add note offset</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; asl a</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_LO, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda note_table+1, y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_HI, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp1&#xA0;&#xA0;&#xA0;&#xA0; ;restore data stream index</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;...snip...</span><br>&#xA0;&#xA0; &#xA0;<br>Imagine what would happen if we have stream_note_offset set to 2.&#xA0; Say we read a C4 note from the data stream:<br>&#xA0;&#xA0; &#xA0;<br>1. A C4 note is equivalent to hex value #$1b (see aliases in note_table.i)<br>2. we add stream_note_offset to this value.&#xA0; #$1b + #$02 = #$1d.<br>3. hex value #$1d is equivalent to a D4 note (see note_table.i)<br>4. wow, we raised the note up a step!<br><br>Using the same value for stream_note_offset, if we had a string of notes like this:<br><br><span style="font-family: Courier New;">C4, E4, G4, B4, C5, E5, G5, E5, B5, C6 ;Cmaj7</span><br style="font-family: Courier New;"><br>it would get translated to:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">D4, Fs4, A4, C#5, D5, Fs5, A5, C#6, D6 ;Dmaj7</span><br><br>Using
stream_note_offset we can easily transpose entire sections of music
into other keys.&#xA0; As mentioned above, we will initialize a stream&apos;s
stream_note_offset to zero:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_load:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip---</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda #$00</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_offset, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;---snip---</span><br>&#xA0;&#xA0; &#xA0;<br><b>Set Note Offset</b><br>Now let&apos;s make an opcode that will set stream_note_offset to a specific value:<br><br><span style="font-family: Courier New;">;-----------------------------------------------------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;this is our JUMP TABLE!</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_infinite_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_duty&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_set_loop1_counter&#xA0;&#xA0; ;$A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A5</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .word se_op_set_note_offset&#xA0;&#xA0;&#xA0;&#xA0; ;$A6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;these are aliases to use in the sound data.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">endsound = $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop = $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">volume_envelope = $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">duty = $A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">set_loop1_counter = $A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop1 = $A5</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">set_note_offset = $A6</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_set_note_offset:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read the argument</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_offset, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;set the note offset.</span><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br><br>Now we can set the note offset anytime we want in the data stream:<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">;oops, after writing the song, I realized I wanted it to be in D instead.&#xA0; No problem.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_data:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_note_offset, 2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C2, C3, C4, C5, ;etc.. more notes in the key of C.</span><br>&#xA0;&#xA0; &#xA0;<br><b>Adjust Note Offset</b><br>Setting
the note offset to a specific value has very limited application.&#xA0; It&apos;s
like a one-time keychange.&#xA0; More often we will want to set the note
offset to some relative value.&#xA0; For example, instead of setting
stream_note_offset to 2, we might want to set stream_note_offset to
&quot;the current offset + 2&quot;.&#xA0; If we had an opcode that let us adjust
stream_note_offset by a relative value, we could use it together with
loops.&#xA0; First let&apos;s write the opcode:<br><br><span style="font-family: Courier New;">;-----------------------------------------------------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;this is our JUMP TABLE!</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_infinite_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_duty&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_set_loop1_counter&#xA0;&#xA0; ;$A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A5</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_set_note_offset&#xA0;&#xA0;&#xA0;&#xA0; ;$A6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.word se_op_adjust_note_offset&#xA0; ;$A7</span></span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;these are aliases to use in the sound data.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">endsound = $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop = $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">volume_envelope = $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">duty = $A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">set_loop1_counter = $A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop1 = $A5</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">set_note_offset = $A6</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">adjust_note_offset = $A7</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_adjust_note_offset:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read the argument (what value to add)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_note_offset, x&#xA0;&#xA0; ;add it to the current offset</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_offset, x&#xA0;&#xA0; ;and save.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>Let&apos;s look at this opcode in use.&#xA0; Say we have a long arpeggiated line like this:<br><br><span style="font-family: Courier New;">C2, E2, G2, B2, C3, E3, G3, B3, C4, E4, G4, B4, C5, E5, G5, B5, C6, E6, G6, B6, C7 ;Cmaj7 (21 bytes)</span><br><br>This passage just repeats the same 4 notes (C E G B) over 5 octaves. &#xA0;<br><br><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_loop1_counter, 5&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;loop 5 times</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C2, E2, G2, B2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;these are the 4 notes to loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte adjust_note_offset, 12&#xA0;&#xA0;&#xA0; ;each iteration add 12 to the offset (ie, go up an octave)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;will be a C7.&#xA0; Cmaj7 (12 bytes)</span><br>&#xA0;&#xA0; &#xA0;<br>The
first time through the loop it will play C2, E2, G2, B2.&#xA0; The second
time through the loop it will play C3, E3, G3, B3.&#xA0; The third time
through will be C4, E4, G4, B4, etc.&#xA0; Using our opcodes, we reduce the
size of our data from 21 bytes to 12 bytes.&#xA0; That&apos;s almost 50% savings.<br><br><b>Battle Kid</b><br>To take a better example, let&apos;s look at the bassline to the Battle Kid theme song.&#xA0; Last week, it looked like this:<br><br><span style="font-family: Courier New;">song6_tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, A3, A4, A4, A3, A3, A4, A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte G3, G3, G4, G4, G3, G3, G4, G4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;down a step (-2)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte F3, F3, F4, F4, F3, F3, F4, F4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;down a step (-2)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte Eb3, Eb3, Eb4, Eb4, Eb3, Eb3, Eb4, Eb4&#xA0;&#xA0;&#xA0; ;down a step (-2)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song6_tri</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;36 bytes</span><br>&#xA0;&#xA0; &#xA0;<br>We have a pattern here: <span style="font-family: Verdana;">X3, X3, X4, X4, X3, X3, X4, X4</span>,
where X = some note.&#xA0; It just so happens that each new X is just the
previous X minus 2. Using our new opcode, we can rewrite the bassline
like this:<br><br><span style="font-family: Courier New;">song6_tri:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_loop1_counter, 4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;repeat 4 times</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A3, A3, A4, A4, A3, A3, A4, A4&#xA0;&#xA0;&#xA0; ;series of notes to repeat</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte adjust_note_offset, -2&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;go down a step</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_note_offset, 0&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;after 4 repeats, reset note offset to 0.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;infinite loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song6_tri&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; &#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ;21 bytes</span><br>&#xA0;&#xA0; &#xA0;<br>We drop from 36 bytes to 21 bytes of ROM space.&#xA0; About 40% savings!<br>&#xA0;&#xA0; &#xA0;<br><b>Loopy Sound Effects</b><br>We can produce some cool sound effects if we combine loops and key changes at high tempos.&#xA0; Look at this one (tempo is $FF):<br><br style="font-family: Courier New;"><span style="font-family: Courier New;">song7_square2:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_loop1_counter, $08&#xA0;&#xA0;&#xA0; ;repeat 8 times</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte thirtysecond, D7, D6, G6&#xA0; ;play two D notes at different octaves and a G.&#xA0; Pretty random</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte adjust_note_offset, -4&#xA0;&#xA0;&#xA0; ;go down 2 steps</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte endsound</span><br>&#xA0;&#xA0; &#xA0;<br>This
sound effect plays a simple 3-note pattern in descending keys super
fast.&#xA0; The sound data is only 12 bytes, but it produces a pretty
complex sound effect.&#xA0; Listen to song7 in this week&apos;s sample files to
hear it.&#xA0; By experimenting with loops like this we can come up with
some sounds that would be difficult to compose by hand.<br>&#xA0;&#xA0; &#xA0;<br><b><font size="3">Complex Chord Progressions</font></b><br>We
made some good savings percentage-wise on the bassline to Battle Kid.&#xA0;
But we were lucky.&#xA0; The chord progression went down in consistent
steps: -2, -2, -2.&#xA0; It was possible to loop this because we adjust the
note_offset by the same value (-2) each time.&#xA0; But what if we had a
pattern that was repeated in a more complicated way?&#xA0; We do.&#xA0; Let&apos;s
look at the rhythm pattern for our Guardian Legend boss song:<br><br><span style="font-family: Courier New;">song1_square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A2, A2, A2, A3, A2, A3, A2, A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte F3, F3, F3, F4, F3, F4, F3, F4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;+8 (A2 + 8 = F3)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A2, A2, A2, A3, A2, A3, A2, A3&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;-8</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte F3, F3, F3, F4, F3, F4, F3, F4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;+8</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte E3, E3, E3, E4, E3, E4, E3, E4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte E3, E3, E3, E4, E3, E4, E3, E4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;+0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte Ds3, Ds3, Ds3, Ds4, Ds3, Ds4, Ds3, Ds4&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte D3, D3, D3, D4, D3, D4, D3, D4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte C3, C3, C3, C4, C3, C4, C3, C4&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;-2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte B2, B2, B2, B3, B2, B3, B2, B3&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte As2, As2, As2, As3, As2, As3, As2, As3&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A2, A2, A2, A3, A2, A3, A2, A3&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte Gs2, Gs2, Gs2, Gs3, Gs2, Gs3, Gs2, Gs3&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte G2, G2, G2, G3, G2, G3, G2, G3&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;-1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;+2 (loop back to A2)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song1_square1</span><br>&#xA0;&#xA0; &#xA0;<br>Here
we have another pattern: Xi, Xi, Xi, Xi+1, Xi, Xi+1, Xi, Xi+1, where X
= some note and i = some octave.&#xA0; Cool.&#xA0; A pattern means we have an
opportunity to save bytes by looping.&#xA0; But wait.&#xA0; Unlike Battle Kid,
this pattern jumps around in an inconsistent way.&#xA0; What should we do?<br><br><b>Super TGL Transposition Trick</b><br>I learned this trick from The Guardian Legend, so I call it the <b>TGL Transposition Trick</b>.&#xA0;
What we do is we loop the pattern, and then use the loop counter as an
index into a lookup table.&#xA0; The lookup table contains note offset
values.&#xA0; Because the loop counter decrements, our lookup table will be
sequentially backwards.<br><br>Wait, what?&#xA0; Let&apos;s looks at our example:<br><br><span style="font-family: Courier New;">song1_square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_loop1_counter, 14&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;repeat 14 times</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A2, A2, A2, A3, A2, A3, A2, A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">;pull a value from lookup_table and</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; ; add it to stream_note_offset</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;finite loop (14 times)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;infinite loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song1_square1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.lookup_table:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte 2, -1, -1, -1, -1, -1, -2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte -1, -1, 0, -1, 8, -8, 8&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;14 entries long, reverse order</span><br>&#xA0;&#xA0; &#xA0;<br>I&apos;m
going to break it down in a second here, but first let me tell you that
the part highlighted in red above will be covered by a single opcode,
transpose.&#xA0; The transpose opcode takes a 2-byte argument, so altogether
that commented section will be replaced with 3 bytes of data.&#xA0; So if we
count up all of the bytes in our rhythm sound data we get 34 bytes.&#xA0;
The original was 116 bytes.&#xA0; By using the TGL Transposition Trick, we
save 82 bytes.&#xA0; That&apos;s 70%!<br><br><span style="font-family: Courier New;">song1_square1:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte eighth</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte set_loop1_counter, 14&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;repeat 14 times</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.loop:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte A2, A2, A2, A3, A2, A3, A2, A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; <span style="color: rgb(255, 0, 0);">.byte transpose&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;the transpose opcode take a 2-byte argument</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0);"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .word .lookup_table&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;which is the address of the lookup table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;finite loop (14 times)</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word .loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;infinite loop</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word song1_square1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">.lookup_table:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte 2, -1, -1, -1, -1, -1, -2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .byte -1, -1, 0, -1, 8, -8, 8&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;14 entries long, reverse order</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">;*** altogether 34 bytes ***</span><br><br>The
transpose opcode will set up a pointer variable to point to the lookup
table.&#xA0; Then it will take the loop counter, subtract 1, and use the
result as an index into the table.&#xA0; We subtract 1 because the tables
index from zero.&#xA0; If we loop 14 times, our table will have 14 entries
numbered 0-13.&#xA0; Once the transpose opcode has its index, it will pull a
value from the table.&#xA0; This value will be added to stream_note_offset.<br><br>Before
we write the opcode, let&apos;s trace through the data to see how it works.&#xA0;
We&apos;ll start at the very first byte of song1_square1:<br><br>1) set note length to eighth notes<br>2) set the loop counter to 14<br><br>(.loop iteration 1)<br>3) play a series of notes: A2, A2, A2, A3, A2, A3, A2, A3<br>4)
transpose opcode.&#xA0; Setup a pointer to lookup_table.&#xA0; Use our loop
counter, minus one, as an index.&#xA0; The loop counter is 14 now, so we
will pull out .lookup_table+13, which is an 8.&#xA0; Add 8 to the current
stream_note_offset: 0 + 8 = 8.<br>5) decrement the loop counter (14-&gt;13) and loop back to the .loop label<br><br>(iteration 2)<br>6) our new string of notes with the +8: F3, F3, F3, F4, F3, F4, F3, F4. <br>7) transpose opcode.&#xA0; Loop counter is 13.&#xA0; Grab .lookup_table+12, which is -8.&#xA0; Add -8 to stream_note_offset: 8 + -8 = 0.<br>8) decrement loop counter (13-&gt;12) and loop back to .loop label<br><br>(iteration 3)<br>9) our new string of notes with the +0: A2, A2, A2, A3, A2, A3, A2, A3 <br>10) transpose opcode.&#xA0; Loop counter is 12.&#xA0; Grab .lookup_table+11, which is 8.&#xA0; Add 8 to stream_note_offset: 0 + 8 = 8.<br>11) decrement loop counter (12-&gt;11) and loop back to .loop label<br><br>(iteration 4)<br>12) our new string of notes with the +8: F3, F3, F3, F4, F3, F4, F3, F4. <br>13) transpose opcode.&#xA0; Loop counter is 11.&#xA0; Grab .lookup_table+10, which is -1.&#xA0; Add -1 to stream_note_offset: 8 + -1 = 7.<br>14) decrement loop counter (11-&gt;10) and loop back to .loop label<br><br>(iteration 4)<br>15) our new string of notes with the +7: E3, E3, E3, E4, E3, E4, E3, E4. <br>16) transpose opcode.&#xA0; Loop counter is 10.&#xA0; Grab .lookup_table+9, which is 0.&#xA0; Add 0 to stream_note_offset: 7 + 0 = 7.<br>17) decrement loop counter (10-&gt;9) and loop back to .loop label<br><br>etc.&#xA0;
On the last iteration our loop counter is 1.&#xA0; We grab .lookup_table+0
and add it to stream_note_offset.&#xA0; Then we decrement the loop counter
(1-&gt;0).&#xA0; Our loop counter is now 0, so our loop breaks.&#xA0; Pretty
cool, no?&#xA0; Let&apos;s write it.<br><br><span style="font-family: Courier New;">;-----------------------------------------------------------------------</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;this is our JUMP TABLE!</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">sound_opcodes:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_endsound&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_infinite_loop&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_change_ve&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_duty&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_set_loop1_counter&#xA0;&#xA0; ;$A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_loop1&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A5</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_set_note_offset&#xA0;&#xA0;&#xA0;&#xA0; ;$A6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; .word se_op_adjust_note_offset&#xA0; ;$A7</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">&#xA0;&#xA0;&#xA0; .word se_op_transpose&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;$A8</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">;these are aliases to use in the sound data.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">endsound = $A0</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop = $A1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">volume_envelope = $A2</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">duty = $A3</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">set_loop1_counter = $A4</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">loop1 = $A5</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">set_note_offset = $A6</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">adjust_note_offset = $A7</span><br style="font-family: Courier New;"><span style="font-family: Courier New; color: rgb(255, 0, 0);">transpose = $A8</span><br style="font-family: Courier New;"><br style="font-family: Courier New;"><span style="font-family: Courier New;">se_op_transpose:</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read low byte of the pointer to our lookup table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta <span style="color: rgb(255, 0, 0);">sound_ptr2</span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;store it in a new pointer variable</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; iny</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [sound_ptr], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read high byte of pointer to table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta <span style="color: rgb(255, 0, 0);">sound_ptr2</span>+1</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sty sound_temp&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;save y because we are about to destroy it</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda stream_loop1, x&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;get loop counter, put it in Y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; tay&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;&#xA0;&#xA0; this will be our index into the lookup table</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; dey&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;subtract 1 because indexes start from 0.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; lda [<span style="color: rgb(255, 0, 0);">sound_ptr2</span>], y&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;read a value from the table.</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; clc</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; adc stream_note_offset, x&#xA0;&#xA0; ;add it to the note offset</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; sta stream_note_offset, x</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; ldy sound_temp&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; ;restore Y</span><br style="font-family: Courier New;"><span style="font-family: Courier New;">&#xA0;&#xA0;&#xA0; rts</span><br>&#xA0;&#xA0; &#xA0;<br>There
is a new pointer variable here, sound_ptr2.&#xA0; Actually, what I really
did was rename jmp_ptr to sound_ptr2.&#xA0; The new name let&apos;s me know it&apos;s
for sound engine use only.&#xA0; Since we finish with jmp_ptr as soon as we
jump, there are no pointer conflicts here.<br><br><b>Conclusion</b><br>This
is just an example of how clever use of opcodes and looping can save
you lots of bytes.&#xA0; Keep in mind that this transpose opcode is only
useful if you write music that has repeating patterns in the rhythm
section.&#xA0; If you don&apos;t, then save yourself some bytes and cut the
opcode from your sound engine.<br><br><b>Putting It All Together</b><br>Download and unzip the <a href="downloads/NerdyNightsSoundSourceCollection/opcodes2.zip" target="_blank">opcodes2.zip</a> sample files.&#xA0; Make sure the following files are in the same folder as NESASM3:<br><br>&#xA0;&#xA0;&#xA0; opcodes2.asm<br>&#xA0;&#xA0;&#xA0; sound_engine.asm<br>&#xA0;&#xA0;&#xA0; sound_opcodes.asm<br>&#xA0;&#xA0;&#xA0; opcodes2.chr<br>&#xA0;&#xA0;&#xA0; note_table.i<br>&#xA0;&#xA0;&#xA0; note_length_table.i<br>&#xA0;&#xA0;&#xA0; vol_envelopes.i<br>&#xA0;&#xA0;&#xA0; song0.i<br>&#xA0;&#xA0;&#xA0; song1.i<br>&#xA0;&#xA0;&#xA0; song2.i<br>&#xA0;&#xA0;&#xA0; song3.i<br>&#xA0;&#xA0;&#xA0; song4.i<br>&#xA0;&#xA0;&#xA0; song5.i<br>&#xA0;&#xA0;&#xA0; song6.i<br>&#xA0;&#xA0;&#xA0; song7.i<br>&#xA0;&#xA0;&#xA0; opcodes2.bat<br><br>Double click opcodes2.bat. That will run NESASM3 and should produce the opcodes2.nes file. Run that NES file in FCEUXD SP.<br><br>Use the controller to select songs and play them.&#xA0; Controls are as follows:<br>&#xA0;&#xA0; &#xA0;<br><b>Up</b>: Play<br><b>Down</b>: Stop <br><b>Right</b> : Next Song/SFX<br><b>Left</b> : Previous Song/SFX<br><br>Song0 is a silence song.&#xA0; Not selectable.<br>Song1-Song6 are the same as last week, but they take up less ROM-space now<br>Song7 is a new sound effect created by looping a key change at high tempo.<br><br>As usual, try adding your own songs and sound effects in using the new opcodes.&#xA0; Experiment.<br><br><b>Next Week</b>: <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=27943" target="_blank">Noise, Simple Drums</a><br>
				